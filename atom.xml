<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>All your need is love and a little bit of LSD</title>
    <link href="https://ndtimofeev.github.io/atom.xml" rel="self" />
    <link href="https://ndtimofeev.github.io" />
    <id>https://ndtimofeev.github.io/atom.xml</id>
    <author>
        <name>Nikita Timofeev</name>
        <email>ndtimofeev@gmail.com</email>
    </author>
    <updated>2015-12-27T00:00:00Z</updated>
    <entry>
    <title>Список реакци которые мне доводилось ставить</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-12-27-reaction-list.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-12-27-reaction-list.html</id>
    <published>2015-12-27T00:00:00Z</published>
    <updated>2015-12-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Вот что удалось вспомнить:</p>
<ol>
<li>Реакция Гриньяра</li>
<li>Металл-галлидный обмен</li>
<li>Реакция Габриэля</li>
<li>Реакция Анри</li>
<li>Гидрирование азидов с платиной на угле</li>
<li>Реакция азо-Виттега</li>
<li>Реакция Финкельштейна</li>
<li>Восстановление двойной связи боргидридом натрия</li>
<li>Восстановление иминов цианоборгидридом натрия</li>
<li>Прямое броммирование фенонов</li>
<li>Прямое броммирование замещённых электронодонорных ароматических соединений</li>
<li>Броммирование замещённых электронодонорных ароматических соединений NBS’ом</li>
<li>Алкилирование фенолов галогеналканами</li>
<li>Формилирование ароматических соединений по Вильсмайеру</li>
<li>Формилирование дихлорметилметиловым эфиром</li>
<li>Окисление спиртов по Сверну</li>
<li>Замещение алифатического галлогена на азид</li>
<li>Получение сложных эфиров прямой этерификацией</li>
<li>Ацилирование по Фриделю-Крафтцу</li>
<li>Получение алкенов дегидратированием спиртов</li>
</ol>]]></summary>
</entry>
<entry>
    <title>О MskHUG в декабре 2015го года…</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-12-11-meetup.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-12-11-meetup.html</id>
    <published>2015-12-11T00:00:00Z</published>
    <updated>2015-12-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Сходил на слёт хаскелистов в Яндексе, послушал доклады. Коротко:</p>
<ul>
<li><p>Лучший доклад был пожалуй про Servant. Человек настолько задороно выступил, что мне захотелось оный Servant потыкать, хотя у меня и нет задач для которых мог бы понадобится веб-сервер. Чуваку, который сравнивал сложность комбинирования роутов веб-сервера и сложность комбинирования парсеров в parsec посылаю луч ненависти: во втором случае сложность вылезает из-за типично нетревиальных грамматик и того что парсек говно и не умеет в бэктрекинг (но это совсем другая история).</p></li>
<li><p>Наиболее полезным для меня оказался доклад про зависимые типы, который оказался не про зависимые типы, а про костыли в GHC, которые позволяют типизировать типы типами. Собственно я наконец примерно понял как работает этот механизм. А вот квантор <code>pi</code> мне напомнил С++14 с его <code>decltype(auto)</code>.</p></li>
<li><p>Зефиров опять рассказывал что-то очень интересное и я опять мало что смог вынести из доклада: во-первых опоздал к началу, во-вторых сам доклад проводился в экстремальных условиях и в-третьих Зефиров довольно хреновый докладчик.</p></li>
<li><p>Крайне полезным был доклад <span class="citation">@qnikst</span><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>’а. Жаль что он не успел его дочитать. Всё бы ничего, но мне как-то стабильно не нужно вызывать внешние функции из haskell руками. Обычно дело ограничивается сериализацией/десериализацией сишных структур прилетевших из ядерных интерфейсов. Хотя идея хакнуть рантайм через unsafe ffi-вызовы, которые блокируют тред и gc мне показалась очень интересной, хотя и вредной.</p></li>
<li><p>Посмотрел на живого <del>Ленина</del><span class="citation">@qnikst</span>’а. Он классный <del>,от него сияние исходит</del>.</p></li>
<li><p>Попытался объяснить живому <span class="citation">@segfault</span>’у радость комбинатора неподвижной точки.</p></li>
<li><p>Попытался объяснить живому <span class="citation">@segfault</span>’у радость GREEN’а, полнопрограмной компиляции и отказа от стека в пользу распихивания аргументов функций по фиксированным непересекающимся регистрам.</p></li>
</ul>
<p>Больше не сделал ничего ползного. В следующий раз нужно будет запастись:</p>
<ul>
<li><p>Бейджем с ником на жуйке.</p></li>
<li><p>Карточками с вопросами, чтобы передавать их по кругу по столу во время неформальной части.</p></li>
<li><p>Докладом про Remote Monad, если к этому времени мой <code>Action</code> будет честным частным случаем.</p></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>[http://juick.com/qnikst]<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Список книг которые надо прочитать</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-11-09-books.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-11-09-books.html</id>
    <published>2015-11-09T00:00:00Z</published>
    <updated>2015-11-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="мне">Мне</h3>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/Выкрикивается_лот_49">Выкрикивается лот 49</a></li>
<li>Дневник одного гения</li>
</ul>
<h3 id="всем">Всем</h3>
<ul>
<li>Степной волк</li>
<li>Сидхартха</li>
<li>1984</li>
<li>О дивный новый мир</li>
<li>Маятник Фуко</li>
<li>Невыносимая лёгкость бытия</li>
<li>Циники</li>
<li>Волшебник Земноморья</li>
</ul>]]></summary>
</entry>
<entry>
    <title>О скоупах</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-08-02-scope.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-08-02-scope.html</id>
    <published>2015-08-02T00:00:00Z</published>
    <updated>2015-08-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>А вот ещё одна хитрая задачка. Положим у нас есть несколько устройств, которые мы можем как-то дёргать через <code>DevHnd a</code> (где <code>a</code> — тип-параметр характеризующий устройство). Проблема в том, что если два треда будут рулить устройством одновременно, то результат будет трудно предсказать. Хорошо, вводим концепцию владения устройством: управлять устройством<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> можно только завладев им, если кто-то другой завладел устройством до тебя, то ты ждёшь пока устройство освободится. Просто, но есть пара нюансов:</p>
<ul>
<li>мы говорим «блокировка» и подразумеваем «дедлок», поскольку в реальной жизни тред должен контролировать состояние более одного устройства одновременно;</li>
<li>из типа <code>DevHnd a</code> никак не следует захвачен ли он текущим тредом, а значит проверка этого факта будет осуществляться в рантайме каждый раз когда мы будем модифицировать устройство и более того время от времени мы будем сталкиваться с ошибками времени исполнения.</li>
</ul>
<p>В общем случае, когда устройства захватываются и высвобождаются в произвольный момент времени ни первую, ни вторую проблему мы вероятнее всего не решим. Но если рассмотреть ситуацию когда все устройства захватываются и освобождаются одновременно ситуация перестаёт быть такой удручающей и внезапно укладывается в традиционный для haskell’я паттерн:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> c
    withSomething dev1 dev2 action <span class="fu">=</span> <span class="kw">do</span>
        alloc dev1 dev2
        v <span class="ot">&lt;-</span> action
        dealloc dev1 dev2
        return v</code></pre></div>
<p>Способов заблокировать несколько сущностей одновременно избежав дедлоков более одного, выберите по вкусу. Но <code>action</code> всё равно может содержать действия с устройствами, которые мы не захватили. Чтобы этого избежать можно сделать следующее:</p>
<ul>
<li>введём изоморфный <code>DevHnd a</code> тип <code>StaticHnd s a</code> с фантомным параметром <code>s</code> и приватную функцию <code>toStatic</code> делающую из первого второе;</li>
<li>введём изоморфную <code>IO a</code> монаду <code>Scope a</code>, а также функции для управления устройствами внутри этой монады через <code>StaticHnd s a</code>;</li>
<li>перепишем предыдущий код так:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c
    withSomething dev1 dev2 action <span class="fu">=</span> <span class="kw">do</span>
        alloc dev1 dev2
        v <span class="ot">&lt;-</span> action (toStatic dev1) (toStatic dev2)
        dealloc dev1 dev2
        return v</code></pre></div>
<p>Всё. Теперь следим за руками:</p>
<ul>
<li>изменять в нашем скоупе устройства через <code>DevHnd a</code> мы не можем, поскольку соответствующий мутатор не определён для <code>Scope a</code>;</li>
<li>создать <code>StaticHnd s a</code> мы можем только при помощи <code>withSomething</code>, поскольку <code>toStatic</code> не экспортирован наружу;</li>
<li>вернуть <code>StaticHnd s a</code> из <code>action</code> мы тоже не можем, поскольку функция не может вернуть значение любого типа, а фантомный параметр <code>s</code> передаваемых в неё аргументов объявлен как <code>forall</code>.</li>
</ul>
<p>Из всего этого следует что любая попытка использовать внутри нашего скоупа не захваченное устройство или устройство захваченное в другой скоуп (кроме родительского :^)) завершится <strong>ошибкой компиляции</strong>. Хорошо? Очень хорошо. Но на этом хорошее заканчивается и начинается Real World.</p>
<p>Приведённый код определён для двух устройств захватываемых в скоуп. Очевидным образом это довольно частный случай и этого мало. Также очевидно что функция <code>withSomething</code> содержит детали приватной реализации и должна быть чёрным ящиком. Есть несколько вариантов решения:</p>
<ul>
<li><p>Наиболее распространённым решением таких проблем в haskell’е это… унылая копипаста в результате которой получатся функции вида:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c

<span class="ot">withSomething2 ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c

<span class="ot">withSomething3 ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> c <span class="ot">-&gt;</span>
    (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s c <span class="ot">-&gt;</span> <span class="dt">Scope</span> d) <span class="ot">-&gt;</span> <span class="dt">IO</span> d</code></pre></div>
<p>И так до тех пор пока не надоест.</p></li>
<li><p>Также можно попробовать изобразить композицию.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">action <span class="fu">=</span>
    withSomething hnd1 <span class="fu">$</span> \sHnd1 <span class="ot">-&gt;</span>
        withSomething hnd2 <span class="fu">$</span> \sHnd2 <span class="ot">-&gt;</span>
            withSomething hnd3 <span class="fu">$</span> \sHnd3 <span class="ot">-&gt;</span> <span class="kw">do</span>
                doSomething sHnd1
                doSomething sHnd2
                doSomething sHnd3</code></pre></div>
<p>Но так мы теряем возможность захватывать устройства одной транзакцией (у каждого <code>withSomething</code> своя транзакция). В принципе это можно пофиксить введя ещё одну стадию заправки ракеты:</p>
<ul>
<li>вводим ещё одну монаду<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> (например Accure a) внутри которой можно делать только withSomething и run;</li>
<li>withSomething просто добавляет захват очередного устройства в готовящуюся транзакцию;</li>
<li>run запускает транзакцию и затем выполняет наш Scope.</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    action <span class="fu">=</span> accure <span class="fu">$</span>
        withSomething hnd1 <span class="fu">$</span> \sHnd1 <span class="ot">-&gt;</span>
            withSomething hnd2 <span class="fu">$</span> \sHnd2 <span class="ot">-&gt;</span>
                withSomething hnd3 <span class="fu">$</span> \sHnd3 <span class="ot">-&gt;</span> run <span class="fu">$</span> <span class="kw">do</span>
                    doSomething sHnd1
                    doSomething sHnd2
                    doSomething sHnd3</code></pre></div>
<ul>
<li><p>Наконец есть магия в стиле <code>Applicative</code> позволяющая писать что-то в духе:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(\v1 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1
(\v1 v2 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1 <span class="fu">&lt;*&gt;</span> doSome2
(\v1 v2 v3 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1 <span class="fu">&lt;*&gt;</span> doSome2 <span class="fu">&lt;*&gt;</span> doSome3</code></pre></div>
<p>Я даже видел как что-то подобное использовали в parsec’е, но от попыток натянуть это на свои типы у меня стабильно плавится мозг.</p></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>В данном случае это не так принципиально, но под управлением устройством разумеется подразумевается изменение его состояния.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Если у вас монада головного мозга конечно. Достаточно моноида, же.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Список фильмов которые надо посмотреть или пересмотреть</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-02-17-films.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-02-17-films.html</id>
    <published>2015-02-17T00:00:00Z</published>
    <updated>2015-02-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="пересмотреть-или-показать">Пересмотреть или показать</h3>
<ul>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Нирвана_(фильм,_1997)">Нирвана (1997)</a></dt>
<dd>Длительность: 113 мин
</dd>
<dd>Молодой Кристофер Ламберт, наркотики, безысходность, уши Гибсона торчащие из каждого угла, всё кончается очень сомнительно. Что ещё надо-то для счастья? Наверное то что хороших фильмов в декорациях киберпанка очень немного и этот я вспоминаю раньше чем того же «Джонни-Мнемоника», например.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Чернокнижник">Чернокнижник (1989)</a></dt>
<dd>Длительность: 102 мин
</dd>
<dd>Ещё один фильм атмосферу которого можно резать ножом и кушать ложкой. Злой, очень злой, Джулиан Ассандж творит на экране всё что хочет: вступает в сношения с дьяволом, летает, калечит людей, убивает детей. Испуганные или на глухо долбанутые люди пытаются ему противостоять при помощи посыпания поваренной солью и забивания железного гвоздя в след. Они всё это делают зачем-то, но это всё абсолютно не имеет значения и не мешает сосредоточится на том что действительно важно. На чистом зле.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Весна,_лето,_осень,_зима…_и_снова_весна">Весна, лето, осень, зима… и снова весна (2003)</a></dt>
<dd>При том что фильм на корейском, он отлично смотрится без перевода, что само по себе уже любопытно. И ничего не поделаешь, но это Ким Ки Дук.
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Синяя_птица_(мультфильм)">Синяя птица (1970)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Мёбиус_(фильм,_1996)">Мёбиус (1996)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Тринадцатый_этаж">Тринадцатый этаж (1999)</a></dt>
<dd>Это как Матрица, но без акрабатики, перестрелок, спецэффектов и гораздо смелее по своей идее.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Тёмный_город_(фильм,_1998)">Тёмный город (1998)</a></dt>
<dd>Это как Матрица, но без компьютеров с инопланетянами и гораздо мрачнее. Можно смотреть хотя бы из-за атмосферы нуара.
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Кот_раввина">Кот раввина (2011)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Хранители_(фильм)">Хранители (2009)</a></dt>
<dd>«…Когда скопившиеся грязь похоти и убийств вспенится им до пояса, все шлюхи и политиканы посмотрят вверх и возопят: “Спаси нас!”, а я прошепчу: “НЕТ”…»
</dd>
</dl></li>
<li><dl>
<dt>Престиж (2007)</dt>
<dd>Лучший фильм Кристофера Нолана и один из лучших фильмов вообще, прекрасные актёры, прекрасный Дэвид Боуи.
</dd>
</dl></li>
<li><dl>
<dt>Даун Хаус (2001)</dt>
<dd>«…— Это не заело. Это хаус. В моем противоречивом прошлом — молодёжная эстрада…»
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Страх_и_ненависть_в_Лас-Вегасе">Страх и ненависть в Лас (1998)</a> и <a href="https://ru.wikipedia.org/wiki/В_отрыв!">В отрыв! (1999)</a></dt>
<dd>Два наиболее объективных фильма про наркотики из тех что я знаю. Персонажи не садятся в тюрьму, им не отпиливают руку, они не занимаются проституцией за наркотики. С ними вообще объективно не происходит ничего плохого или хорошего. Примерно как и бывает в жизни.
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Бешеные_псы">Бешеные псы (1992)</a> и <a href="https://ru.wikipedia.org/wiki/Криминальное_чтиво">Криминальное чтиво (1994)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Лабиринт_(фильм)">Лабиринт (1986)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Догвилль">Догвилль (2003)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Антихрист_(фильм,_2009)">Антихрист (2009)</a></dt>
<dd>Это было очень тяжёлое и плохое путешествие. Теперь, когда мне говорят о Ларсе фон Триере я вспоминаю именно это. Но возможно я хочу этим с кем-то поделиться.
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Шестиструнный_самурай">Шестиструнный самурай (1998)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Голод_(фильм,_1983)">Голод (1983)</a></dt>
<dd>Длительность: 97 минут
</dd>
</dl></li>
</ul>
<h3 id="посмотреть">Посмотреть</h3>
<ul>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Преследование_(фильм,_1998)">Преследование (1998)</a></dt>
<dd>фильм Кристофера Нолана
</dd>
</dl></li>
<li><dl>
<dt>Интерстеллар (2014)</dt>
<dd>фильм Кристофера Нолана
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Одержимая_(фильм,_1981)">Одержимая (1981)</a></dt>
<dd>фильм Анджея Жулавского
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Шаманка_(фильм)">Шаманка (1996)</a></dt>
<dd>фильм Анджея Жулавского
</dd>
</dl></li>
<li>Восход Люцифера (1980)</li>
<li>Пробуждение моего демонического брата (1969)</li>
<li>Торжественное открытие храма наслаждений (1954)</li>
<li>Трудно быть богом (2013)</li>
<li>Жидкое небо (1983)</li>
<li>Обед нагишом (1991)</li>
<li>Вход в пустоту (2009)</li>
<li>Помутнение (2006)</li>
<li><a href="https://ru.wikipedia.org/wiki/Мертвец_(фильм)">Мертвец (1995)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Tamala_2010:_A_Punk_Cat_in_Space">Tamala 2010: A Punk Cat in Space (2007)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Код_46">Код 46 (2003)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Страх_темноты">Страх темноты (2007)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Выживут_только_любовники">Выживут только любовники (2013)</a></li>
<li>Баба Яга (1973)</li>
<li><a href="https://ru.wikipedia.org/wiki/Экзистенция_(фильм)">Экзистенция (1999)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Печальная_баллада_для_трубы">Печальная баллада для трубы (2010)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Железное_небо">Железное небо (2012)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Двойник_(фильм,_2013)">Двойник (2013)</a></dt>
<dd>экранизация Достоевского
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Временная_петля_(фильм,_2007)">Временная петля (2007)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Омерзительная_восьмёрка">Омерзительная восьмёрка (2016)</a></dt>
<dd>фильм Квентина Тарантино
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Джанго_освобождённый">Джанго освобождённый (2012)</a></dt>
<dd>фильм Квентина Тарантино
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Бесславные_ублюдки">Бесславные ублюдки (2009)</a></dt>
<dd>фильм Квентина Тарантино
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Доказательство_смерти">Доказательство смерти (2007)</a></dt>
<dd>фильм Квентина Тарантино
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Джеки_Браун">Джеки Браун (1997)</a></dt>
<dd>фильм Квентина Тарантино
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Мандерлей">Мандерлей (2005)</a></dt>
<dd>фильм Ларса фон Триера
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Танцующая_в_темноте">Танцующая в темноте (2000)</a></dt>
<dd>фильм Ларса фон Триера ну и Бьорк на экране
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Нимфоманка_(фильм)">Нимфоманка (2013)</a></dt>
<dd>фильм Ларса фон Триера
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Ребёнок_Розмари">Ребёнок Розмари (1968)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/THX_1138">THX 1138 (1971)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Последнее_искушение_Христа">Последнее искушение Христа (1988)</a></dt>
<dd>Длительность: 164 минут
</dd>
<dd>Самое время пересмотреть фильмографию Дэвида Боуи. Ну и Скорсезе.
</dd>
</dl></li>
<li><dl>
<dt>Gutterdämmerung (2016)</dt>
<dd>Совершенно непонятно о чём идёт речь и будет ли это записано на киноплёнку, но хочу.
</dd>
</dl></li>
</ul>
<h3 id="попробовать-посмотреть">Попробовать посмотреть</h3>
<ul>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/На_серебряной_планете">На серебряной планете (1987)</a></dt>
<dd>фильм Анджея Жулавского
</dd>
</dl></li>
<li>Святая гора (1973)</li>
<li>Святая кровь (1989)</li>
<li>Другие ипостаси (1980)</li>
<li><a href="https://ru.wikipedia.org/wiki/Тупик_(фильм,_1970)">Тупик (1970)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Кунг_Фьюри">Кунг Фьюри (2015)</a></li>
<li><a href="https://en.wikipedia.org/wiki/It&#39;s_Such_a_Beautiful_Day_(film)">It’s Such a Beautiful Day (2012)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Мне_скучно,_бес">Мне скучно, бес (1993)</a></li>
<li><dl>
<dt>Иерей-сан (2015)</dt>
<dd>сценарий Охлабыстина
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Соловей-Разбойник_(фильм)">Соловей-Разбойник (2012)</a></dt>
<dd>сценарий Охлабыстина
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Арбитр_(фильм)">Арбитр (1992)</a></dt>
<dd>сценарий Охлабыстина
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Урод_(фильм)">Урод (1993)</a></dt>
<dd>сценарий Охлабыстина
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Мусорщик">Мусорщик (2001)</a></dt>
<dd>сценарий Охлабыстина
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Кто_я">Кто я (2014)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Бёрдмэн">Бёрдмэн (2014)</a></dt>
<dd>Майкл Китон играет Майкла Китона
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Меланхолия_(фильм,_2011)">Меланхолия (2011)</a></dt>
<dd>фильм Ларса фон Триера
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Рассекая_волны">Рассекая волны (1996)</a></dt>
<dd>фильм Ларса фон Триера
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Перекрёсток_Миллера">Перекрёсток Миллера (1990)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Человек,_который_упал_на_Землю">Человек, который упал на Землю (1976)</a></dt>
<dd>Длительность: 138 мин
</dd>
<dd>Самое время пересмотреть фильмографию Дэвида Боуи.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Счастливого_Рождества,_мистер_Лоуренс">Счастливого Рождества, мистер Лоуренс (1983)</a></dt>
<dd>Длительность: 124 мин
</dd>
<dd>Самое время пересмотреть фильмографию Дэвида Боуи.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Супер">Супер (2010)</a></dt>
<dd>Длительность: 96 мин
</dd>
<dd>Треш от человека который умеет делать треш
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Стражи_Галактики_(фильм)">Стражи Галактики (2014)</a></dt>
<dd>Длительность: 121 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Письма_мёртвого_человека">Письма мёртвого человека (1986)</a></dt>
<dd>Длительность: 88 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Господин_оформитель">Господин оформитель (1988)</a></dt>
<dd>Длительность: 103 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Вельд_(фильм)">Вельд (1997)</a></dt>
<dd>Длительность: 81 мин
</dd>
</dl></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Jolla</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-07-17-Jolla.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-07-17-Jolla.html</id>
    <published>2014-07-17T00:00:00Z</published>
    <updated>2014-07-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Jolla — это тот самый линукс-смартфон который мы все так ждали. Здесь всё как на десктопе: искоропки ничего не работает, накатываешь обновления — становится лучше, дорабатываешь напильником — получается худо-бедно что-то работоспособное. Зато масса удовольствия от напильника и общения с разработчиками, а также очень неплохая звонилка и таймерная служба искоропки.</p>
<!--more-->
<p>Впечатления от устройства самые противоречивые. Первое что бросается в глаза — это не Нокия. Ни тебе цельного корпуса из поликарбоната защищающего устройство от ударов, ни тебе AMOLED дисплея позволяющего без лишних затрат рисовать часы на заблокированном экране, ни тебе фрезеровки. В общем нет в нём искры гнева Божьего. Затем ты включаешь телефон и начинается самое интересное.</p>
<ol>
<li><p>Не работает вообще ничего. Телефон может только звонить и отправлять сообщения. Специальная программа учит тебя пользоваться жестовым интерфейсом (который со времён n9 как-то стал одновременно и удобнее и перегруженнее). Из многочисленной периферии работает только камера, wifi и gsm-модуль. Можно посмотреть чужие фотографии. Интернет настоятельно рекомендует обновиться. Окей, обновляемся.</p></li>
<li><p>Не работает регистрация в сервисах Jolla (которая по старой доброй традиции пришедшей ещё из Nokia необходима чтобы получать обновления). Получив от меня все необходимые данные и соединившись с глобальной сетью через wifi телефон сообщает что что-то пошло не так. После беглого поиска в интернете узнаю, что у меня уже есть регистрационная запись в сервисе Jolla и создавать вторую привязанною к тому же почтовому адресу нельзя, а сказать мне это более доступным способом телефон не умеет. Окей, заходим на сайт Jolla, через веб-интерфейс сбрасываем пароль, меняем его вводим его на телефоне, обновляемся.</p></li>
<li><p>Не работает LTE. Тупо не активен нужный пункт меню. Читаем интернет. Это не помогает. Сбрасываем телефон к чёртовой бабушки до заводских настроек. После первого пакета обновлений обнаруживаем нужный пункт меню активным и на всякий случай вбиваем туда параметры APN своего сотового оператора. Обновляемся окончательно, всё работает.</p></li>
<li><p>Не работает подключение телефона к компьютеру как usb-storage поскольку корень с /home’ом сидит на btrfs. Надо заметить, что стек технологий там вообще интересный: корень на btrfs, инит-система — systemd, а графика на waylend. Зато можно выгрузить фотографии digiKam’ом как с камеры или подключить по mtp как плеер. Последнее у меня не получилось из-за KDE-проблем и я решил просто монтировать устройство по сети через sshfs.</p></li>
<li><p>Не работает ssh. Прочитал инструкцию и форум — не помогает. Путём тыканья эмулятора терминала на самом телефоне (он кстати шикарный, хотя и не без недостатков) я обнаружил что для sshd не сгенерирована пара ключей. Потому он и не стартует. Сгенерировал их руками в той же консоли и всё заработало.</p></li>
<li><p>Не работает NFC. Ну то есть работает (в частности через NFC-модуль телефон читает RFID-метку на цветной крышке), но интерфейса для управления NFC-модуля пока нет и никакой возможности узнать что оный модуль вообще есть на борту не влезая в консоль или документацию тоже нет.</p></li>
</ol>
<p>Продолжение следует…</p>
<p>Тех кому кажется что у меня слишком много спойлеров могу успокоить: Jolla позаботилась о своих пользователях и выдала каждому уникальный набор багов требующий своего особого напильника. Во всяком случае именно это ощущение возникает при чтении их форума-стекэксчендж-багзиллы.</p>
<p>Возможно у вас возник закономерный вопрос: если всё так плохо, то что же чёрт подери я приобретаю за кровные 350€ кроме политического волеизъявления? Где же тут луч света в тёмном царстве? Их есть у нас.</p>
<ul>
<li><p>Во-первых это просто красиво. Нет. Это охренительно красиво. Видимо это как-то связано с qml’ем и возможностью переверстать каждый элемент интерфейса упоротым дизайнером, но описывать это совершенно бессмысленно. Даже если вы не сможете пользоваться данным устройством, вы всегда можете подарить его своей женщине, которая будет использовать его как очень красивый лаунчер андроид-приложения и джаббер-клиент (который там искоропки) для общения с вами.</p></li>
<li><p>Во-вторых это общение. Что может быть прекраснее обсуждения на специальном стекэксчендж форуме (который там вместо багзиллы) возникших в процессе использования проблем с другими пользователями и разработчиками? Пользователи рассказывают как обходить проблемы, разработчики обещают починить баги или приделать фичу, пользователи не только находят баги, но временами даже чинят их, разработчики жалуются на перспективу остаться без блоба от snapdragon года через полтора. Идиллия.</p></li>
<li><p>В-третьих это эргономика. Если не вдаваться в подробности, то основная идея интерфейса Jolla это замена тыканья в виджет пальцем на сдвиг экрана в произвольном месте в нужную сторону, что требует гораздо меньше ловкости, а также бессмысленного перемещения пальца над экраном. Основная задача — осуществлять все основные манипуляции с телефоном одним, вероятнее всего большим пальцем, вероятнее всего левой руки, вероятнее всего на бегу. В целом это даже получается. Хотя при этом очень забавно, что для этих целей устройство слишком велико и не умеет Swype.</p></li>
<li><p>В-четвёртых это ожидание чуда. Сам процесс превращения кирпича в твоих руках в более-менее работоспособное устройство стоит любых денег.</p></li>
</ul>
<p>Теперь серьёзно.</p>
<ul>
<li><p>Если вы фанатичный политически активный линуксоид купите себе устройство чтобы поддержать финский стартап «пошедший против системы». В худшем случае подарите своей женщине.</p></li>
<li><p>Если вы эталонный хипстер купите себе устройство потому что оно выглядит довольно стильно и встречается примерно на два-три порядка реже чем iPhone (это Sailfish OS, но вы наверное даже не слышали о том что это такое).</p></li>
<li><p>Если вы красноглазый гик и вам очень нужно менять порядок монтирования файловых систем при загрузке вашего телефона или возможность подцепить к нему по i2c какой-то свой контроллер купите себе устройство потому как за вычетом дизайнеров разработчики устройства примерно такие же люди. Все вышеперечисленные проблемы вас никак не коснуться.</p></li>
<li><p>Если вы чувствуете себя линуксоидом, но у вас нет лишних 350€ чтобы отдать их в фонд помощи замерзающих финов портируйте Sailfish OS на Nexus, n9 или то устройство которое у вас есть под рукой. Почему бы и нет.</p></li>
</ul>
<p>Во всех остальных случаях просто купите себе андроид, поскольку на данный момент устройство является красивым андроид лаунчером. Это правда никак не относится к вашему покорному слуге, который получил от устройства всё то чего ему так давно не хватало: возможность осуществлять звонки не выходя на крышу, задавать множество таймеров на различные задачи и поставить Five to One на будильник.</p>]]></summary>
</entry>
<entry>
    <title>Немного о лунном.</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-06-18-about-lua.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-06-18-about-lua.html</id>
    <published>2014-06-18T00:00:00Z</published>
    <updated>2014-06-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Лунный примечателен тем что это очень простой язык. Несмотря на такие языковые возможности как анонимные функции и замыкания это очень традиционный процедурный язык. Языковые конструкции в нём означают примерно то чего от них и ждёшь. Его простота столь велика что определённым образом провоцирует беспечность программиста. В следствие этой беспечности столкновения со специфичными для языка вещами обычно бывают особенно болезненны и полны детской обиды. Здесь перечислено несколько элементарных моментов, столкновение с которыми у программиста не на лунном может вызвать недоумение и предварительное ознакомление с которыми должно упростить вхождение в язык тем кто так и не прочёл документацию<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<ol>
<li><p>Массивы индексируются начиная с единицы<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">v <span class="ot">=</span> <span class="ot">{</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">,</span> <span class="dv">3</span> <span class="ot">}</span>

<span class="kw">for</span> i <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="ot">#</span>v <span class="kw">do</span>
    <span class="fu">print</span><span class="ot">(</span> v<span class="ot">[</span>i<span class="ot">]</span> <span class="ot">)</span>
<span class="kw">end</span>

<span class="co">-- nil</span>
<span class="co">-- 0</span>
<span class="co">-- 1</span>
<span class="co">-- 2</span>
<span class="co">-- 3</span></code></pre></div></li>
<li><p>Все переменные глобальные, если не указано что они локальные<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">x <span class="ot">=</span> <span class="dv">1</span>
y <span class="ot">=</span> <span class="dv">13</span>

z <span class="ot">=</span> <span class="kw">function</span><span class="ot">()</span>
    x <span class="ot">=</span> <span class="dv">0</span>
    <span class="kw">local</span> y <span class="ot">=</span> <span class="dv">0</span>
<span class="kw">end</span>

<span class="fu">print</span><span class="ot">(</span> x<span class="ot">,</span> y <span class="ot">)</span>
z<span class="ot">()</span>
<span class="fu">print</span><span class="ot">(</span> x<span class="ot">,</span> y <span class="ot">)</span>

<span class="co">-- 1    13</span>
<span class="co">-- 0    13</span></code></pre></div></li>
<li><p>Захват переменных в область видимости (в том числе и в замыкания) осуществляется по ссылке или по имени<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. Таким образом можно невозбранно модифицировать переменные из замыкания в которое они захвачены. Но при передаче значения в функцию в качестве аргумента создаётся новая <strong>локальная</strong> ссылка и изменения переменной во внешней области видимости происходить не будет<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">x <span class="ot">=</span> <span class="dv">1</span>
y <span class="ot">=</span> <span class="dv">13</span>

z <span class="ot">=</span> <span class="kw">function</span><span class="ot">(</span> v <span class="ot">)</span>
    v <span class="ot">=</span> <span class="dv">0</span>
    y <span class="ot">=</span> <span class="dv">0</span>
<span class="kw">end</span>

<span class="fu">print</span><span class="ot">(</span> x<span class="ot">,</span> y <span class="ot">)</span>
z<span class="ot">(</span> x <span class="ot">)</span>
<span class="fu">print</span><span class="ot">(</span> x<span class="ot">,</span> y <span class="ot">)</span>

<span class="co">-- 1    13</span>
<span class="co">-- 1    0</span></code></pre></div></li>
<li><p>Если инициализировать локальную переменную анонимной функцией, то она не будет доступна внутри области видимости анонимной функции. Таким образом мы вполне можем вызывать такую функцию рекурсивно<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">f <span class="ot">=</span> <span class="kw">function</span><span class="ot">(</span> x <span class="ot">)</span>
    f<span class="ot">(</span> x <span class="ot">)</span>
<span class="kw">end</span>

<span class="co">-- Всё в порядке. Путь к переполнению стека открыт.</span>

<span class="kw">local</span> f1 <span class="ot">=</span> <span class="kw">function</span><span class="ot">(</span> x <span class="ot">)</span>
    f1<span class="ot">(</span> x <span class="ot">)</span>
<span class="kw">end</span>

<span class="co">-- Всё плохо.</span>

<span class="kw">local</span> f2
f2 <span class="ot">=</span> <span class="kw">function</span><span class="ot">(</span> x <span class="ot">)</span>
    f2<span class="ot">(</span> x <span class="ot">)</span>
<span class="kw">end</span>

<span class="co">-- А вот так, как не странно, всё хорошо.</span></code></pre></div></li>
<li><p>В lua свои собственные особенные регулярные выражения<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>.</p>
<ul>
<li>Эскейпинг магических символов осуществляется при помощи ‘%’.</li>
<li>Символы пунктуации нуждаются в эскейпинге.</li>
<li>‘-’ это такой ленивый ‘*’.</li>
<li>Ну и расширений по мелочи.</li>
</ul></li>
<li><p>Знак неравенства. Поскольку все современные промышленные языки программирования так или иначе произошли от C (Java и C#, например), у программиста нет сомнений относительно того как должен выглядеть оператор неравенства — <strong>!=</strong>. А между тем из числа арифметических операторов и условных операторов форма этого оператора пожалуй наиболее непостоянна: <strong>/=</strong> в Haskell, <strong>&lt;&gt;</strong> в Pascal и PHP. лунном неравенство это неожиданно <strong>~=</strong><a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="fu">print</span><span class="ot">(</span> <span class="dv">1</span> <span class="er">!=</span> <span class="dv">2</span> <span class="ot">)</span>

<span class="co">-- Ошибка компиляции</span>

<span class="fu">print</span><span class="ot">(</span> <span class="dv">1</span> <span class="ot">~=</span> <span class="dv">2</span> <span class="ot">)</span>

<span class="co">-- А вот так просто true</span></code></pre></div></li>
<li><p>Форматированный вывод чисел. Поскольку в лунном языке нет целых чисел и вместо них используют числа с плавающей запятой двойной точности, то переполнение величины в 2<sup>51</sup> приводит к потере точности целой части. Однако при преобразование числа в строку, переход от целочисленной к экспоненциальной записи происходит раньше этого предела. Этот переход ошибочно воспринимается некоторыми как потеря точности в целой части, хотя это не так и чинится настройками форматирования.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="fu">print</span><span class="ot">(</span> <span class="dv">2</span> <span class="ot">^</span> <span class="dv">51</span> <span class="ot">)</span>

<span class="co">-- 2.2517998136852e+15</span>

<span class="fu">print</span><span class="ot">(</span> <span class="fu">string.format</span><span class="ot">(</span> <span class="st">&quot;%.0f&quot;</span><span class="ot">,</span> <span class="dv">2</span> <span class="ot">^</span> <span class="dv">51</span> <span class="ot">)</span> <span class="ot">)</span>

<span class="co">-- 225179981368528</span></code></pre></div></li>
<li><p>Nil не может быть последним элементом массива. Если последним элементом массива оказывается nil, массив укорачивается на этот элемент.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">list <span class="ot">=</span> <span class="ot">{</span> <span class="dv">1</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">,</span> <span class="dv">3</span> <span class="ot">}</span>

list<span class="ot">[</span><span class="dv">2</span><span class="ot">]</span> <span class="ot">=</span> <span class="kw">nil</span>

<span class="fu">print</span><span class="ot">(</span> table<span class="ot">.</span>unpack<span class="ot">(</span> list <span class="ot">)</span> <span class="ot">)</span>

<span class="co">-- 1    nil    3</span>

list<span class="ot">[</span><span class="dv">3</span><span class="ot">]</span> <span class="ot">=</span> <span class="kw">nil</span>

<span class="fu">print</span><span class="ot">(</span> table<span class="ot">.</span>unpack<span class="ot">(</span> list <span class="ot">)</span> <span class="ot">)</span>

<span class="co">-- 1</span>

<span class="fu">print</span><span class="ot">(</span> <span class="ot">#{</span> <span class="kw">nil</span><span class="ot">,</span> <span class="kw">nil</span><span class="ot">,</span> <span class="kw">nil</span> <span class="ot">}</span> <span class="ot">)</span>

<span class="co">-- 0</span></code></pre></div></li>
</ol>
<p>Также если вы кондовый сишник, вам безусловно очень понравятся begin и end, но это уже совсем другая история.</p>
<p>P.S: Запись основана на реальных событиях. Каждым из пунктов прострелил себе колено я или кто-то из моих знакомых.</p>
<p>P.P.S: Продолжение следует.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Важно понимать, что никакой тайны из этих вещей не делается. Наоборот, все эти вещи описаны в официальной документации к языку. Она у него кстати довольно короткая. Просто все её читают в лучшем случае по диагонали.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#2.1">здесь</a> где-то начиная с «We use the term sequence…».<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#3.2">здесь</a> начиная с «…Any variable name…».<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Все глобальные переменные связываются по имени. Если точнее то все глобальные переменные просто элементы хэштаблицы _ENV и связывание с ними это поиск значения в этой таблице по имени. Факт этот настолько поразил меня, что не упомянуть о нём совсем я не мог, хотя он и выходит за рамки обсуждения.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#3.2">здесь</a> начиная с «…function’s formal parameter…».<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#3.4.10">здесь</a> начиная с «…The statement local…».<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#6.4.1">здесь</a> всё.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#3.4.3">здесь</a> начиная с «…The operator ~=…».<a href="#fnref8">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Почему хаскель не подходит для скриптования?</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-06-13-why-haskell-bad-for-scripting.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-06-13-why-haskell-bad-for-scripting.html</id>
    <published>2014-06-13T00:00:00Z</published>
    <updated>2014-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Прежде чем обсуждать недостатки такого безусловно примечательного инструмента следует определиться с таким самоочевидным понятием как скриптование. Речь пойдёт в первую очередь о так называемых скриптах пользователя: небольших программах обеспечивающих интерфейс взаимодействия пользователя и более сложной системы. Например скрипты emacs’а, vim’а или даже acpid’а. В определённой степени можно говорить и командной оболочке операционной системы в принципе с некоторыми оговорками. Следует различать пользовательские скрипты и приложения для одного запуска: последние могут сколь угодно сложны, громоздки, запутаны, не очевидны и нечитабельны, поскольку читать их никто не будет и пишутся они обычно на одном дыхание, а со своими скриптами вам скорее всего ещё долгое время жить. Итак пользовательский скрипт это программа:</p>
<ul>
<li>предоставляющая интерфейс к более сложной системе чем система самого скрипта (в противном случае было бы проще поправить код системы)<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>;</li>
<li>небольшая (в противном случае кто кого скриптует и кто куда встроен<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>);</li>
<li>понятная (поскольку никто даже комментариев не пишет, не говоря уж про документацию);</li>
<li>как правило не критичная по производительности.</li>
</ul>
<p>Для таких задач традиционно используются shell, lua, js, scheme и прочие языки поразительно схожие с этими синтаксисом и семантикой (хотя некоторые умудряются для этого сравнительно успешно использовать целый python). Что объединяет эти языки? Слабая (у всех кроме scheme) динамическая типизация и позднее связывание. Оно и понятно, считается что если убрать из программы аннотацию типов то она станет выглядеть проще. Однако на сдачу мы получаем невозможность проверить хотя бы наличие вызываемых функций и существование используемых переменных не говоря уж о разумности применения одного к другому. Поскольку покрывать тестами подобного рода код будут немного позже того как к нему напишут документацию, то ситуация выглядит так себе.</p>
<p>При этом следует понимать, что статическая типизация и ранее связывание вообще говоря совсем не требуют аннотации типов. Компилятор зачастую может понять какой тип имеет то или иное выражение просто из контекста используемых функций. Компилятор может осуществлять вывод типов даже в таком языке как C++, где система типов вообще один из кругов Ада. Для более простого языка это осуществить ещё проще. Всё что ему нужно это твёрдая уверенность, что в середине выполнения программы не появятся новые функции, а семантика существующих типов не изменится. Довольно забавно, но для очерченных нами задач это практически всегда верно поскольку для решения простых задач такие динамические возможности едва ли понадобятся, а сложные мы вроде бы решать и не собирались<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p>Теперь посмотрим в свете наших задач на Haskell. Итак Haskell это ленивый, функциональный язык программирования с полиморфизмом на классах типов:</p>
<ul>
<li>вывод типов вместо динамической типизации: прекрасно работает;</li>
<li>функции высшего порядка вместо метапрограммирования: с учётом возможности определять операторы и тем что у основных конкурентов нет разделения на время компиляции и время исполнения, ок;</li>
<li>полиморфизм всего и вся вместо динамической диспетчеризации: вполне хватает;</li>
</ul>
<p>Плюс сопоставление с образцом, которое у конкурентов как правило отсутствует (ну кроме scheme и прочих лиспов). Что не так? А не так примерно следующее:</p>
<ul>
<li><p>Плохая стандартная библиотека. Многие вещи сделаны плохо поскольку пришли к нам из тех времён когда функциональные языки не умели готовить. Многие вещи сделаны плохо поскольку сделано с учётом особенностей реализации ghc. Так например несмотря на полиморфизм, большая часть функций Prelude мономорфна по используемому контейнеру. Или по используемому числовому типу. В той же стандартной библиотеке есть полиморфные функции, но они запрятаны в другие модули и часто создают конфликт имён, разрешение которого портит всю радость. Ну и за Monad который не Functor отдельное спасибо.</p></li>
<li><p>Сложная стандартная библиотека. В Prelude есть целых два типа для для обозначения целого знакового числа: Int (для числа размером в машинное слово) и Integer (для целого числа бесконечной точности). В Data.Int можно найти целые числа другого размера, а в Data.Word беззнаковые целые числа. Такое разнообразие типов безусловно не доведёт до добра скриптописателя. Он может <del>испугаться</del>начать решать проблемы производительности и не допишет свой скрипт никогда, поскольку будет писать стандартные функции для работы с Word8, отсутствующие в стандартной библиотеке. Для сравнение Lua использует только один тип — Number, который представляет собой закоробкованное число с плавающей запятой двойной точности (то есть Double).</p></li>
<li><p>Стандарт языка. Haskell2010 довольно простой язык у которого есть всё чтобы писать на нём программы. Однако программы эти будут содержать чёртову уйму бойлерплейта, интересных структур данных и коллизий пространств имён. Можно воспользоваться расширениями GHC. Код безусловно станет лаконичнее и яснее, но возникнут другие проблемы: выбор языковых средств (самый банальный пример это функциональные зависимости vs семейства типов), неоднозначности приводящие к трудности проверки типов, усложнение системы типов настолько что язык становится понятным вообще только компилятору. А ещё расширений так много что весь GHC-haskell не знает никто. Вместе с этим, стандартная библиотек старается по возможности избегать языковых расширений, что делает её именно такой как было описано в начале.</p></li>
<li><p>Реализация. Мне на сегодняшний день доводилось иметь дело с тремя реализациями haskell.</p>
<ul>
<li><p>GHC. Мы говорим haskell подразумеваем GHC. Мы говорим о стандартной библиотеке haskell подразумеваем base, а вовсе не haskell2010. Если вы хотите использовать существующие библиотеки то вам придётся использовать GHC. Впрочем это очень хороший компилятор с очень мощной и гибко настраиваемой рантайм-системой: в то время как кто-то всё ещё считает ссылки и никак не выпилит GIL, рантайм-система GHC вертит тысячами тредов и дефрагментирует кучу. Однако у этого всего есть оборотная сторона. GHC громоздок, как в сборке так и в виде библиотеки, а его рантайм избыточен и на небольших приложениях выглядит как лазерная атака из космоса для того чтобы поджарить тосты. Несмотря на все ухищрения и тюнинг рантайма ваше приложение вряд ли будет использовать меньше мегабайта под кучу. Не исключено, что больше тоже вряд ли, но тем не менее.</p></li>
<li><p>Jhc/Ajhc. Компилятор haskell в C. Если GHC придерживается традиционной модели компиляции, где есть раздельная компиляция различных единиц трансляции, а затем линковка, то Jhc проводит анализ, трансформации и компиляцию всего кода проекта. Полученный код на C отчаянно пытается управлять памятью при помощи выведенных регионов, но не справляется и всё в итоге опять скатывается в сканирующую сборку мусора. Эта реализация намного проще и компактнее, но по своей природе больше стремиться быть хаскелем для микроконтроллеров. Язык который она поддерживает — Haskell98 и несколько GHC-шных расширений того времени. Для нашей задачи она бесполезна.</p></li>
<li><p>Haste. Компилятор haskell в JS. Несмотря на жутковатый мапинг данных хаскеля в данные JS и время от времени возникающие проблемы с продолжениями, эта реализация ближе всего к нашим задачам. Haste использует фронтенд ghc и работает уже непосредственно с stg-кодом. Это решает проблему расширений, поскольку почти все они реализованы на уровне фронтенда. И всё же это 40 мегабайт компилятора и 13 — nodejs. Многовато. Кроме того v8 жрёт памяти как не в себя и встраивается только инженерами гугла.</p></li>
</ul></li>
<li><p>Слишком много приведений типов. Вот код на хаскеле:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  avrg xs <span class="fu">=</span> sum xs <span class="fu">/</span> length xs</code></pre></div>
<p>Среднее по списку значение это сумма всех значений в списке разделённая на длину списка. Всё хорошо? Нет. Оператор (/) не определён для целочисленного типа. Длинна списка это значение типа Int. Но даже если она будет Integer или сферический целочисленный тип в вакууме (Integral) ничего не изменится: делитель, делимое и результат должны быть одного типа, а в данном случае нас интересует именно нецелочисленный результат<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. Нужно писать как-то так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  avrg xs <span class="fu">=</span> sum xs <span class="fu">/</span> fromIntegral (length xs)</code></pre></div>
<p>В lua нет такой проблемы поскольку как уже писалось выше там всего один тип для записи чисел вообще. Однако в C (от которого в известной степени хаскель унаследовал примитивные типы) такой проблемы тоже нет: компилятор просто неявно приводит целое число к какой-нибудь плавучке.</p></li>
</ul>
<p>Пущей объективности ради следует заметить, что языки из круга конкурентов совсем не обязательно лишены подобных недостатков. И тем не менее будем считать что всё дело именно в них. Если всё перечисленное плохо и не нужно, то что нужно?</p>
<ul>
<li><p>Компилятор некого семантического надмножества Haskell2010. Стандарт довольно ядра языка довольно лаконичен. Возможно можно было бы исключить из него newtype поскольку он опять же заставляет задумываться, а в нашем случае это плохо. Из расширений стоит оставить:</p>
<ul>
<li><p>Многопараметрические классы типов и функциональные зависимости. Концептуальным решением было бы даже ограничиться классами где все параметры кроме одного зависимы<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p></li>
<li><p>Перегрузка оставшихся немногочисленных литералов. В стандарте перегружены числовые литералы и do-нотация. Соответственно остаётся перегрузить строковые (есть в ghc) и списки (есть в ghc).</p></li>
<li><p>GADT’ы. Упрощают описание древовидных структур и гетерогенных коллекций.</p></li>
<li><p>Data/Generic и прочее обобщённое программирование. В плане унылости мало что может потягаться с case’ом по двенадцати конструкторам, одиннадцать веток которого не делают ничего.</p></li>
<li><p>Управляемое неявное приведение типов.</p></li>
</ul></li>
<li><p>Компиляция неразделяемого кода. Шаблонный полиморфизм как в C++ и jhc. Тотальный инлайнинг и трансформация всего кода программы (интересно, насколько это реально в условиях just it time компиляции).</p></li>
<li><p>Кодогенератор в некую простую существующую переносимую виртуальную машину или даже язык. Предпочтительнее система со сканирующей сборкой мусора (что-то кондовое вроде mark &amp; sweep) и без jit-компилятора. Писать свою динамическую среду исполнения не стоит. Их уже итак больше чем нужно.</p></li>
<li><p>Простая стандартная библиотека.</p>
<ul>
<li><p>Было бы забавно обозвать монаду аппликативным функтором, но не понятно насколько это будет корректно.</p></li>
<li><p>Foldable и Traversable сделать классами от двух переменных где тип содержимого зависит от типа контейнера.</p></li>
<li><p>Не хранить строки в виде списка чаров. Это вызывает слишком много волнения и других строк. По большому счёту строка это массив кодпоинтов, но непонятно как тогда осуществлять паттерн-матчинг.</p></li>
<li><p>Стандартизованный механизм и формат исключений (вот уже GADT и в стандартной библиотеке).</p></li>
<li><p>Стандартные монадные трансформеры? Почему бы и нет. Плюс монада для логического вывода с бэктрекингом.</p></li>
<li><p>Регулярные выражения и комбинаторы парсеров. Последнее вообще киллер-фича функциональшины и ML-подобных.</p></li>
<li><p>Стандартные контейнеры типа Map, Set и так далее.</p></li>
<li><p>Парсеры для работы c json, xml, yaml.</p></li>
</ul></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Ну или у вас просто нет возможности поправить код системы. Но тогда горе побеждённым! Какой смысл обсуждать достоинства и недостатки brainfuck, если это единственный доступный вам способ изменить поведение вашей системы?<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Угу. Например в код emacs на elisp встроено небольшое ядро на C.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Существует спорное утверждение, что динамика очень нужна для создание EDSL’ей которые действительно позволяют повысить простоту кода и довольно эффективно съесть сложность и громоздкость кода.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Иначе у нас бы использовалось целочисленное деление.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Да-да. Это семейства типов. Но они выглядят более громоздкими. Функциональные зависимости более лаконичны что-ли.<a href="#fnref5">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>e</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-05-24-e.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-05-24-e.html</id>
    <published>2014-05-24T00:00:00Z</published>
    <updated>2014-05-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Четыре года назад, я радовался работе с бесконечными списками и вычислял e суммируя ряд Тейлора так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> map (\x <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">/</span> fac x) [<span class="dv">0</span><span class="fu">..</span>]
    <span class="kw">where</span>
        fac n <span class="fu">=</span> foldl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>n]
        sum (x<span class="fu">:</span>xs) <span class="fu">=</span> sumtr (x<span class="fu">:</span>xs) <span class="dv">0</span>
        sumtr (x<span class="fu">:</span>xs) acc
            <span class="fu">|</span> (acc <span class="fu">==</span> acc <span class="fu">+</span> x) <span class="fu">=</span> acc
            <span class="fu">|</span> otherwise <span class="fu">=</span> sumtr xs (x <span class="fu">+</span> acc)</code></pre></div>
<p>Случайно найдя предыдущий сниппет и смахнув слезу умиления, я переписал суммирование уже со знанием стандартной библиотеки.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> takeWhile (<span class="fu">/=</span><span class="dv">0</span>) <span class="fu">$</span> map (\v <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">/</span> product [<span class="dv">1</span><span class="fu">..</span>v]) [<span class="dv">0</span><span class="fu">..</span>]</code></pre></div>
<p>Проблема в том, что этот вариант аллоцировал в 10 раз больше памяти чем первый. Стало как-то неудобно и я заменил вычисление факториала для каждого нового члена ряда Тейлора на вычисление непрерывного списка факториалов, где каждый следующий элемент умножение номера члена ряда на значение предыдущего элемента.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> takeWhile (<span class="fu">/=</span><span class="dv">0</span>) <span class="fu">$</span> map (<span class="dv">1</span><span class="fu">/</span>) <span class="fu">$</span> scanl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>]</code></pre></div>
<p>Количество аллоцированной памяти вышло на уровень первого варианта. Однако в первом варианте у нас используется наивный факториал и он всё равно работает замечательно. Разница состоит в том, что первый вариант суммирует ряд до тех пор пока сумма изменяется, а третий — до тех пор пока n-ый член ряда не станет нулём. Любому кто знаком с числами с плавающей запятой понятно что первое условие выполнится быстрее второго. Попробуем использовать именно первое условие. Для этого из бесконечного списка факториалов получим бесконечный список сумм, выделим пары текущая сумма/следующая сумма и будем разматывать список до тех пор пока суммы не равны. Последняя сумма и есть наша.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> fst <span class="fu">$</span> last <span class="fu">$</span> takeWhile (uncurry (<span class="fu">/=</span>)) <span class="fu">$</span> (\v <span class="ot">-&gt;</span> zip v (tail v)) <span class="fu">$</span> scanl1 (\v0 v1 <span class="ot">-&gt;</span> v0 <span class="fu">+</span> <span class="dv">1</span> <span class="fu">/</span> v1) <span class="fu">$</span> scanl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>]</code></pre></div>
<p>Мы наконец заметно превзошли по выделенной памяти первый вариант. Но не в 10 раз, а в полтора и ценой дополнительного времени на сборку мусора. Это скажем так себе результат.</p>
<p>P.S: Продолжение следует.</p>]]></summary>
</entry>

</feed>
