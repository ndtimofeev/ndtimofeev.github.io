<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>All your need is love and a little bit of LSD</title>
    <link href="https://ndtimofeev.github.io/atom.xml" rel="self" />
    <link href="https://ndtimofeev.github.io" />
    <id>https://ndtimofeev.github.io/atom.xml</id>
    <author>
        <name>Nikita Timofeev</name>
        <email>ndtimofeev@gmail.com</email>
    </author>
    <updated>2016-05-20T00:00:00Z</updated>
    <entry>
    <title>О том как избежать успеха и как не избежать успеха…</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2016-05-20-GHC8-callstack.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2016-05-20-GHC8-callstack.html</id>
    <published>2016-05-20T00:00:00Z</published>
    <updated>2016-05-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="успех-сам-себя-не-избежит">Успех сам себя не избежит</h2>
<p>При всём богатстве возможностей в Haskell регулярно возникают проблемы с вещами, которые кажутся совершенно элементарными. Например получить стек вызовов в случае ошибки. Причём не то что бы его нельзя получить совсем, наоборот есть как минимум два ортогональных способа, но всё это сопряжено с таким количеством сложностей и условий, что проще воткнуть в нужные места printf’ы или густо обмазываться препроцессором. Особенно грустно дело с этим обстояло в ghci.</p>
<p>И вот для пользователей ghci наступает <a href="http://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html">революция</a>. Казалось бы страдания остались в прошлом, а <code>error</code> и <code>undefined</code> обрели практическое применение. Однако первая же попытка использовать это в массиве написанного кода обернулась неудачей: <code>error</code> и <code>undefined</code> выдавали стек вызовов, а броски исключения — нет. Сначала я подозревал себя в том, что куда-то не включил профилировочную информацию или как-то не так использую ImplicitParams, но потом я просто полез в код.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Err.hs:77</span>
<span class="ot">    undefined ::</span> forall (<span class="ot">r ::</span> <span class="dt">RuntimeRep</span>)<span class="fu">.</span> forall (<span class="ot">a ::</span> <span class="dt">TYPE</span> r)<span class="fu">.</span>
                 <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> a
    undefined <span class="fu">=</span>  error <span class="st">&quot;Prelude.undefined&quot;</span></code></pre></div>
<p>Тут всё понятно: <code>undefined</code> это такой частный случай <code>error</code> для тех кому не хватило фантазии написать осмысленное сообщение. Улыбаемся “Prelude.undefined” и двигаемся дальше.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Err.hs:36</span>
<span class="ot">    error ::</span> forall (<span class="ot">r ::</span> <span class="dt">RuntimeRep</span>)<span class="fu">.</span> forall (<span class="ot">a ::</span> <span class="dt">TYPE</span> r)<span class="fu">.</span>
             <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> a
    error s <span class="fu">=</span> raise<span class="fu">#</span> (errorCallWithCallStackException s <span class="fu">?</span>callStack)</code></pre></div>
<p>Тут в принципе ожидалось увидеть что-то вроде <code>throw . ErrorCall</code>, но не оно. С другой стороны <code>raise#</code> это такой primop, который реализует throw, так что <code>errorCallWithCallStackException</code> должен быть таким замысловатым способом сконструировать исключение. За подтверждением лезем в <code>GHC.Exception</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Exception.hs:171</span>
    <span class="kw">data</span> <span class="dt">ErrorCall</span> <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> <span class="dt">String</span> <span class="dt">String</span>
        <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)

    pattern <span class="dt">ErrorCall</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ErrorCall</span>
    pattern <span class="dt">ErrorCall</span> err <span class="ot">&lt;-</span> <span class="dt">ErrorCallWithLocation</span> err _ <span class="kw">where</span>
      <span class="dt">ErrorCall</span> err <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> err <span class="st">&quot;&quot;</span>

    <span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">ErrorCall</span>

    <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">ErrorCall</span> <span class="kw">where</span>
      showsPrec _ (<span class="dt">ErrorCallWithLocation</span> err <span class="st">&quot;&quot;</span>) <span class="fu">=</span> showString err
      showsPrec _ (<span class="dt">ErrorCallWithLocation</span> err loc) <span class="fu">=</span> showString (err <span class="fu">++</span> <span class="ch">&#39;\n&#39;</span> <span class="fu">:</span> loc)

<span class="ot">    errorCallException ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeException</span>
    errorCallException s <span class="fu">=</span> toException (<span class="dt">ErrorCall</span> s)</code></pre></div>
<p>Первое что нас удивляет: конструктор <code>ErrorCall</code> теперь называется как-то по другому и таскает не одну строчку, а два. Впрочем если посмотреть <a href="http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html">тут</a> то фокус с конструктором и синонимом становится понятен.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Exception.hs:187</span>
<span class="ot">    errorCallWithCallStackException ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">CallStack</span> <span class="ot">-&gt;</span> <span class="dt">SomeException</span>
    errorCallWithCallStackException s stk <span class="fu">=</span> unsafeDupablePerformIO <span class="fu">$</span> <span class="kw">do</span>
      ccsStack <span class="ot">&lt;-</span> currentCallStack
      <span class="kw">let</span>
        implicitParamCallStack <span class="fu">=</span> prettyCallStackLines stk
        ccsCallStack <span class="fu">=</span> showCCSStack ccsStack
        stack <span class="fu">=</span> intercalate <span class="st">&quot;\n&quot;</span> <span class="fu">$</span> implicitParamCallStack <span class="fu">++</span> ccsCallStack
      return <span class="fu">$</span> toException (<span class="dt">ErrorCallWithLocation</span> s stack)</code></pre></div>
<p>Теперь собственно виновник торжества. Получаем явный стек в качестве переменной, достаём стек профилировщика хакнув IO, красиво рисуем, склеиваем, запихиваем в расширенный <code>ErrorCall</code> вместе с сообщением, заворачиваем в <code>SomeException</code>. Если посмотреть на инстанс <code>Show</code> для <code>ErrorCall</code>, то можно увидеть код, который рисует стек если соответствующее поле заполнено. Снаружи никаких изменений в <code>ErrorCall</code> не видно. Отличный пример того как можно при помощи паттерн-синонимов в GHC8 можно изобразить инкапсуляцию. Теперь смотрим на <code>throw</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Exception.hs:166</span>
<span class="ot">    throw ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> a
    throw e <span class="fu">=</span> raise<span class="fu">#</span> (toException e)</code></pre></div>
<p>Ну конечно. Тут просто неоткуда взяться стек-трейсу. Да как бы он хранился в исключение произвольного типа? Разве что как-то так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">data</span> <span class="dt">SomeException</span> <span class="kw">where</span>
        <span class="dt">SomeExceptionWithLocation</span><span class="ot"> ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">SomeException</span>

    pattern <span class="dt">SomeException</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">SomeException</span>
    pattern <span class="dt">SomeException</span> err <span class="ot">&lt;-</span> <span class="dt">SomeExceptionWithLocation</span> _ err <span class="kw">where</span>
      <span class="dt">SomeException</span> err <span class="fu">=</span> <span class="dt">SomeExceptionWithLocation</span> <span class="st">&quot;&quot;</span> err</code></pre></div>
<h2 id="работать-вокруг">Работать вокруг</h2>
<p>Разобраться с тем почему ничего не работает хорошо, но было бы ещё лучше понять что нужно сделать чтобы оно заработало. В данном случае ответ простой: модифицировать стандартную библиотеку так, чтобы <code>SomeException</code> таскал за собой информацию о стеке вызовов[^1]. Однако, увы, у меня такой возможности нет. Можно вместо <code>SomeException</code> модифицировать типы исключений, которые выбрасываются в коде. Тогда придётся ещё и написать функцию, которая будет заполнять новый тип нужными данными. Также будем исходить из соображения, что нам лениво явным образом включать информацию о стеке вызовов в каждый тип исключение и мы напишем обёртку для всех исключений сразу.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE ImplicitParams #-}</span>

<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Control.Exception</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Typeable</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">GHC.Stack</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">System.IO.Unsafe</span>

<span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">CallStackException</span> <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="dt">CallStackException</span><span class="ot"> ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">CallStackException</span>

<span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">CallStackException</span></code></pre></div>
<p>Пока похоже на правду.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">CallStackException</span> <span class="kw">where</span>
<span class="fu">&gt;</span>     show (<span class="dt">CallStackException</span> e <span class="st">&quot;&quot;</span>)    <span class="fu">=</span> show e
<span class="fu">&gt;</span>     show (<span class="dt">CallStackException</span> e stack) <span class="fu">=</span> show e <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span> stack</code></pre></div>
<p>Наша обёртка не несёт никакого смысла для получателя исключения, так что показывать нам особо нечего. Если исключение прилетело без стек-трейса показываем только вложенное исключение. Если вместе со стек-трейсом то вложенное исключение и стек-трейс на следующей строке. Теперь нам нужен аналог <code>throwIO</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> throwIO&#39; ::</span> (<span class="dt">HasCallStack</span>, <span class="dt">Exception</span> e) <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="fu">&gt;</span> throwIO&#39; e <span class="fu">=</span> <span class="kw">do</span>
<span class="fu">&gt;</span>     stack <span class="ot">&lt;-</span> currentCallStack
<span class="fu">&gt;</span>     throwIO <span class="fu">$</span> <span class="dt">CallStackException</span> e <span class="fu">$</span> <span class="kw">if</span> stack <span class="fu">/=</span> []
<span class="fu">&gt;</span>         <span class="kw">then</span> prettyCallStack <span class="fu">?</span>callStack <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span> renderStack stack
<span class="fu">&gt;</span>         <span class="kw">else</span> prettyCallStack <span class="fu">?</span>callStack</code></pre></div>
<p>Вычитываем текущий стек вызовов профилировщика, выбрасываем наружу исключение в обёртке со стеком состоящем из <code>ImplicitParams</code>-стека и стека профилировщика, если он не пустой. Ничего интересного. Давайте для красоты добавим:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> throw&#39; ::</span> (<span class="dt">HasCallStack</span>, <span class="dt">Exception</span> e) <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> a
<span class="fu">&gt;</span> throw&#39; <span class="fu">=</span> unsafeDupablePerformIO <span class="fu">.</span> throwIO&#39;</code></pre></div>
<p>Теперь можно бросить произвольное исключение и оно будет снабжено стеком вызовов. В принципе это уже весьма неплохо, поскольку в 80% случаев если обработка исключений и осуществляется, то на уровне <code>onException</code>. <code>bracket</code> и прочего <code>finaly</code>. Но положем мы всё же хотим ловить исключения по типу. У нас ничего не выйдет, поскольку в <code>SomeException</code> завёрнуто исключение не того типа который мы ловим, а типа-обёртки. Можно решить эту проблему двумя способами. Во-первых можно почитать документацию в <code>Control.Exception</code> и перегрузить <code>toException</code> и <code>fromException</code> для интересующих нас типов исключений таким образом чтобы он учитывал наличие обёртки. Но это придётся делать для каждого типа-исключения. Во-вторых мы можем написать свой волшебный <code>catch</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> exceptionLoop ::</span> (<span class="dt">Exception</span> a, <span class="dt">Exception</span> e) <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> b
<span class="fu">&gt;</span> exceptionLoop ex f abort
<span class="fu">&gt;</span>     <span class="fu">|</span> <span class="dt">Just</span> (<span class="dt">SomeException</span> inner)        <span class="ot">&lt;-</span> cast ex <span class="fu">=</span> exceptionLoop inner f abort
<span class="fu">&gt;</span>     <span class="fu">|</span> <span class="dt">Just</span> (<span class="dt">CallStackException</span> inner _) <span class="ot">&lt;-</span> cast ex <span class="fu">=</span> exceptionLoop inner f abort
<span class="fu">&gt;</span>     <span class="fu">|</span> <span class="dt">Just</span> v                            <span class="ot">&lt;-</span> cast ex <span class="fu">=</span> f v
<span class="fu">&gt;</span>     <span class="fu">|</span> otherwise                                    <span class="fu">=</span> abort

<span class="fu">&gt;</span><span class="ot"> catch&#39; ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="fu">&gt;</span> catch&#39; eval f <span class="fu">=</span> catch eval <span class="fu">$</span>
<span class="fu">&gt;</span>      \err<span class="fu">@</span>(<span class="dt">SomeException</span> top) <span class="ot">-&gt;</span> exceptionLoop top f (throwIO err)</code></pre></div>
<p>Ловим все исключения и пытаемся их привести либо к тому типу который ждёт наш обработчик, либо к типам обёрткам. Если нашли обёртку, спускаемся уровнем ниже, если нашли нужный тип — обрабатываем, если не нашли ничего перебрасываем ровно то что получили с сохранением стека. Всё. Мы победили.</p>
<p>Радость правда омрачает то, что у нас есть свои собственные особые функции для того чтобы бросать и ловить исключения и нужно модифицировать весь существующий код. Конечно если он с самого начала был написан с помощью пакета <a href="http://hackage.haskell.org/package/exceptions"><code>exceptions</code></a>, который вводит классы позволяющие перегрузить <code>throwIO</code> и <code>catch</code> для произвольной монады то ситуация выглядит существенно лучше, но модифицировать код для того чтобы его было проще отлаживать всё равно придётся. Кроме того, останутся вызовы <code>throw</code> в коде, который нами не управляется (например в стандартной библиотеке ввода-вывода). Это фейл.</p>
<h2 id="проблемы">Проблемы</h2>
<p>Теперь, когда всем стало ясно, что во всём виноваты мейнтейнеры стандартной библиотеки стоит отметить пару проблем, которые так просто не решить.</p>
<ul>
<li><p>Нарушение ссылочной прозрачности. Рассмотрим вот такой код:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">eval <span class="ot">`catch`</span> (\ex<span class="fu">@</span>(<span class="dt">T</span> v) <span class="ot">-&gt;</span> <span class="kw">if</span> pred v
    <span class="kw">then</span> makeGood
    <span class="kw">else</span> throwIO ex)</code></pre></div>
<p>Нам кажется что в ветке <code>else</code> мы ничего не делаем, просто перебрасываем исключение, которое получили незаметно для кода выше по стеку. На самом деле мы только что обрезали стек вызовов до глубины <code>catch</code>. Конечно можно решить что всё ок и так нам и надо, но это не отменяет того что мы имеем малоочевидный побочный эффект.</p></li>
<li><p>А ещё есть асинхронные исключения, для которых вся эта ерунда вообще не применима. Ну то есть в <code>throwTo</code> безусловно можно вычитать текущий стек-трейс, но какой он имеет смысл для процесса в который исключение бросается? Можно опять же решить что всё ок и для асинхронного исключения стек вызовов не так уж и важен, но если кто-то из обработчиков этого исключения перебросит его как в предыдущем примере то в итоге мы получим стек вызовов означающий примерно ничего.</p></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Поиск устройств на шине 1-wire</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2016-02-20-1-wire-search.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2016-02-20-1-wire-search.html</id>
    <published>2016-02-20T00:00:00Z</published>
    <updated>2016-02-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Поиск устройств на шине 1-wire считается делом не простым и замысловатым. Причиной этого является 64-битный размер идентификатора (на самом деле 8-бит это CRC, но в данном случае это не играет роли) и опросить все возможные идентификаторы на предмет их присутствия на шине за вменяемое время не представляется возможным.</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Пишем функции — затычки для взаимодействия с несуществующей у нас переферией.</span>
<span class="kw">fn</span> one_wire_reset(){}
<span class="kw">fn</span> is_presance() -&gt; <span class="dt">bool</span> { <span class="cn">true</span> }
<span class="kw">fn</span> one_wire_write( c: <span class="dt">u8</span> ){}
<span class="kw">fn</span> read_bit() -&gt; <span class="dt">u8</span> { <span class="dv">1</span> }
<span class="kw">fn</span> read_unbit() -&gt; <span class="dt">u8</span> { <span class="dv">0</span> }

<span class="kw">struct</span> SearchState {
    last_device_flag: <span class="dt">u8</span>,
    last_discrepancy: <span class="dt">u8</span>,
    search_direction: <span class="dt">u8</span>,
    rom_no: <span class="dt">u64</span>
}

<span class="kw">enum</span> SearchResult {
    NotFound,
    Rom( <span class="dt">u64</span> )
}

<span class="kw">fn</span> search_rom( state: &amp;<span class="kw">mut</span> SearchState ) -&gt; SearchResult
{
    <span class="kw">let</span> <span class="kw">mut</span> last_zero: <span class="dt">u8</span> = <span class="dv">0</span>;
    <span class="kw">let</span> <span class="kw">mut</span> result        = SearchResult::NotFound;

<span class="co">// Сбрасываем шину.</span>
    one_wire_reset();

    <span class="kw">if</span> is_presance() &amp;&amp; state.last_device_flag != <span class="dv">1</span>
    {

<span class="co">// Запускаем процесс поиска.</span>
        one_wire_write( <span class="dv">0x0F</span> );

        <span class="kw">for</span> id_bit_number <span class="kw">in</span> <span class="dv">1.</span>.<span class="dv">64</span> {
            <span class="kw">let</span> id_bit     = read_bit();
            <span class="kw">let</span> cmp_id_bit = read_unbit();

            <span class="kw">if</span> id_bit == <span class="dv">1</span> &amp;&amp; cmp_id_bit == <span class="dv">1</span>
            {
                <span class="kw">break</span>;
            }

            state.search_direction =
                <span class="kw">match</span> id_bit_number {
                    _ <span class="kw">if</span> id_bit != cmp_id_bit                    =&gt; id_bit,
                    _ <span class="kw">if</span> id_bit_number == state.last_discrepancy =&gt; <span class="dv">1</span>,
                    _ <span class="kw">if</span> id_bit_number &gt; state.last_discrepancy  =&gt; <span class="dv">0</span>,
                    _                                            =&gt;
                        <span class="kw">if</span> state.rom_no &amp; (<span class="dv">1</span> &lt;&lt; id_bit_number <span class="kw">as</span> <span class="dt">u64</span>) == <span class="dv">0</span> { <span class="dv">0</span> } <span class="kw">else</span> { <span class="dv">1</span> }
                };

            <span class="kw">if</span> state.search_direction == <span class="dv">0</span>
            {
                last_zero = id_bit_number;
                state.rom_no &amp;= !( <span class="dv">1</span> &lt;&lt; id_bit_number <span class="kw">as</span> <span class="dt">u64</span> );
            }
            <span class="kw">else</span>
            {
                state.rom_no |= <span class="dv">1</span> &lt;&lt; id_bit_number <span class="kw">as</span> <span class="dt">u64</span>;
            }

<span class="co">// Отправляем устройствам бит выбранного направления обхода.</span>
            one_wire_write( state.search_direction );

            <span class="kw">if</span> id_bit_number == <span class="dv">64</span>
            {
                result = SearchResult::Rom( state.rom_no );
            }
        }
    }

    <span class="kw">match</span> result {
        SearchResult::Rom( _ ) =&gt;
        {
            state.last_discrepancy = last_zero;

            <span class="kw">if</span> state.last_discrepancy == <span class="dv">0</span> { state.last_device_flag = <span class="dv">1</span> }
        }
        SearchResult::NotFound =&gt;
        {
            state.last_discrepancy = <span class="dv">0</span>;
            state.last_device_flag = <span class="dv">0</span>;
        }
    }

    <span class="kw">return</span> result;
}

<span class="kw">fn</span> main()
{
<span class="co">// Создаём начальный стейт нашего поиска.</span>
    <span class="kw">let</span> <span class="kw">mut</span> state =
                SearchState {
                    last_device_flag: <span class="dv">0</span>,
                    last_discrepancy: <span class="dv">0</span>,
                    search_direction: <span class="dv">0</span>,
                    rom_no: <span class="dv">0</span>
                };

<span class="co">// Ищем устройства до тех пор пока они находятся.</span>
    <span class="kw">loop</span> {
        <span class="kw">match</span> search_rom( &amp;<span class="kw">mut</span> state ) {
            SearchResult::Rom( w ) =&gt; <span class="pp">println!</span>( <span class="st">&quot;{}&quot;</span>, w ),
            SearchResult::NotFound =&gt; <span class="kw">break</span>
        }
    }
}</code></pre></div>]]></summary>
</entry>
<entry>
    <title>Полуэмпирические формулы</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2016-01-29-halfempirical.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2016-01-29-halfempirical.html</id>
    <published>2016-01-29T00:00:00Z</published>
    <updated>2016-01-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Полуэмпирические формулы могут содержать три оротогональных компонента: заряды фрагментов, функциональные группы и плейсхолдеры.</p>
<pre><code>quantifier    = nat &gt; 1

signum        = &#39;+&#39; | &#39;-&#39;

charge        = &#39;(&#39; &#39;+&#39; + &#39;)&#39; | &#39;(&#39; &#39;-&#39; + &#39;)&#39; | &#39;(&#39; quantifier signum &#39;)&#39; | &#39;(&#39; signum quantifier &#39;)&#39;

isotope       = &#39;[&#39; nat atom &#39;]&#39; | &#39;[&#39; atom &#39;]&#39;

placeholder   = &#39;[&#39; [A..z][a..z]* `notElem` element table &#39;]&#39;

              | &#39;[&#39; [A..z][a..z0..9]* &#39;]&#39;

atom          = [A..Z][a..z]{0,2} `elem` element table

linker        = &#39;-&#39; | &#39;=&#39; | &#39;#&#39;

halfempirical = linker{0,1} node linker{0,1} rest*

rest          = node linker{0,1}

unchargednode = isotope quantifier{0,1}

              | atom quantifier{0,1}

              | &#39;(&#39; linker{0,1} unchargednode  &#39;)&#39; quantifier{0,1}

node          = isotope charge{0,1} quantifier{0,1}

              | atom charge{0,1} quantifier{0,1}

              | &#39;(&#39; halfempirical &#39;)&#39; charge{0,1} quantifier{0,1}</code></pre>]]></summary>
</entry>
<entry>
    <title>Моему другу Серёже Алирзаеву посвящается…</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2016-01-26-l29ah.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2016-01-26-l29ah.html</id>
    <published>2016-01-26T00:00:00Z</published>
    <updated>2016-01-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Понапридумывали расширений!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE DeriveTraversable #-}</span>

<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Foldable</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Proxy</span>

<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Peano</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Peano</span>
<span class="fu">&gt;</span>     <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">FixedList</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) a <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">FixedList</span> <span class="dt">Z</span> a
<span class="fu">&gt;</span><span class="ot">     (:.) ::</span> a <span class="ot">-&gt;</span> <span class="dt">FixedList</span> n a <span class="ot">-&gt;</span> <span class="dt">FixedList</span> (<span class="dt">S</span> n) a

<span class="fu">&gt;</span> <span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:.</span>

<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">FixedList</span> n a)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">FixedList</span> n a)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">FixedList</span> n)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Foldable</span> (<span class="dt">FixedList</span> n)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Traversable</span> (<span class="dt">FixedList</span> n)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nill</span>)
<span class="co">-- (2 :. 3 :. 4 :. Nill)</span>

λ<span class="fu">&gt;</span> find (<span class="fu">==</span><span class="dv">2</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nill</span>)
<span class="co">-- Just 2</span>

λ<span class="fu">&gt;</span> mapM_ print (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nill</span>)
<span class="co">-- 1</span>
<span class="co">-- 2</span>
<span class="co">-- 3</span></code></pre></div>
<p>Вроде норм.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sumOurSpecialFixedList ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span>
     <span class="dt">FixedList</span>
       (<span class="ch">&#39;S</span>
          (<span class="ch">&#39;S</span>
             (<span class="ch">&#39;S</span>
                (<span class="ch">&#39;S</span>
                   (<span class="ch">&#39;S</span>
                      (<span class="ch">&#39;S</span>
                         (<span class="ch">&#39;S</span>
                            (<span class="ch">&#39;S</span>
                               (<span class="ch">&#39;S</span>
                                  (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S &#39;</span><span class="dt">Z</span>))))))))))))))))))))
       a
     <span class="ot">-&gt;</span> a
sumOurSpecialFixedList <span class="fu">=</span> sum</code></pre></div>
<p>Чо?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">type</span> family <span class="dt">N2P</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="dt">N2P</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Z</span>
<span class="fu">&gt;</span>     <span class="dt">N2P</span> n <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">N2P</span> (n <span class="fu">-</span> <span class="dv">1</span>))

<span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">FList</span> n <span class="fu">=</span> <span class="dt">FixedList</span> (<span class="dt">N2P</span> n)</code></pre></div>
<p>Чо?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sumOurSpecialFixedList ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">FList</span> <span class="dv">20</span> a <span class="ot">-&gt;</span> a
sumOurSpecialFixedList <span class="fu">=</span> sum</code></pre></div>
<p>Ок.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>) <span class="fu">!!</span> <span class="dv">1</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>
    <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> ‘[a]’
                with actual <span class="kw">type</span> ‘<span class="dt">FixedList</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S &#39;</span><span class="dt">Z</span>))) <span class="dt">Integer</span>’
    <span class="dt">Relevant</span> bindings include<span class="ot"> it ::</span> a (bound at <span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">1</span>)
    <span class="dt">In</span> the first argument <span class="kw">of</span> ‘(<span class="fu">!!</span>)’, namely ‘(<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>)’
    <span class="dt">In</span> the expression<span class="fu">:</span> (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>) <span class="fu">!!</span> <span class="dv">1</span>
    <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>) <span class="fu">!!</span> <span class="dv">1</span></code></pre></div>
<p>Ле!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">type</span> family <span class="dt">P2N</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="dt">P2N</span> <span class="dt">Z</span>     <span class="fu">=</span> <span class="dv">0</span>
<span class="fu">&gt;</span>     <span class="dt">P2N</span> (<span class="dt">S</span> n) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dt">P2N</span> n

<span class="fu">&gt;</span><span class="ot"> findex ::</span> (<span class="dt">KnownNat</span> n, n <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&lt;=</span> <span class="dt">P2N</span> m) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">FixedList</span> m a <span class="ot">-&gt;</span> a
<span class="fu">&gt;</span> findex proxy xs <span class="fu">=</span> toList xs <span class="fu">!!</span> fromInteger (natVal proxy)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XDataKinds</span>
λ<span class="fu">&gt;</span> findex  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">2</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>)
<span class="co">-- 3</span>
λ<span class="fu">&gt;</span> findex  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">0</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>)
<span class="co">-- 1</span></code></pre></div>
<p>Пук. Пёрд. Среньк. Ко-ко-ко-зависимые-типы.</p>]]></summary>
</entry>
<entry>
    <title>O Managed и MonadCatch или что делать если нельзя, но очень хочется…</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2016-01-19-managed.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2016-01-19-managed.html</id>
    <published>2016-01-19T00:00:00Z</published>
    <updated>2016-01-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Есть такой классный человек — <a href="http://www.haskellforall.com/">Gabriel Gonzalez</a>. Он делает с Haskell довольно классные и простые вещи. Зачастую ими совершенно никто не пользуется, но тем не менее они есть и на них стоит посмотреть хотя бы для того чтобы проникнуться и не делать из Хаскеля промышленную Яву. В частности именно он является автором пакета <a href="http://hackage.haskell.org/package/managed">managed</a>, который позволяет <del>экономить отступы</del> управлять ресурсами довольно своеобразным способом.</p>
<h2 id="foo">Что такое Managed?</h2>
<p>Положим у есть файл. и нужно с ним сделать что-то хорошее. Файл надо открыть, получить его <code>Handle</code>, сделать с ним что-то и закрыть. Примерно так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    hnd <span class="ot">&lt;-</span> openFile <span class="st">&quot;path/to/file&quot;</span> <span class="dt">ReadMode</span>
    hPutStrLn hnd <span class="st">&quot;\1051\1103\1093, \1080\1076\1080 \1085\1072 \1093\1091\1081&quot;</span>
    hClose hnd</code></pre></div>
<p>Что будет если попытаться записать что-то в файл открытый на чтение? Вылетит исключение и если его не поймать — тред упадёт. Если он главный и единственный можно заканчивать разговор. Если же есть друге треды то видимо где-то остался висеть открытый файл. Плохо. Хорошо, пишем так.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    hnd <span class="ot">&lt;-</span> openFile <span class="st">&quot;path/to/file&quot;</span> <span class="dt">ReadMode</span>
    hPutStrLn hnd <span class="st">&quot;\1051\1103\1093, \1080\1076\1080 \1085\1072 \1093\1091\1081&quot;</span> <span class="ot">`onException`</span> hClose hnd
    hClose hnd</code></pre></div>
<p>Уже лучше. Правда может прилететь асинхронное исключение из соседнего треда, которое может успеть помешать закрыть файл, но от него можно обезопасить себя при помощи mask. А можно обнаружить в стандартной библиотеке функцию <code>withFile</code>, которая всё это делает за вас примерно так.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    withFile <span class="st">&quot;path/to/file&quot;</span> <span class="dt">ReadMode</span> <span class="fu">$</span> \hnd <span class="ot">-&gt;</span> hPutStrLn hnd <span class="st">&quot;\1051\1103\1093, \1080\1076\1080 \1085\1072 \1093\1091\1081&quot;</span></code></pre></div>
<p>Всё прекрасно до тех пор пока нам не нужно записать содержимое одного файла в другой или даже записать содержимое двух файлов в один:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    withFile <span class="st">&quot;path/to/file&quot;</span> <span class="dt">ReadMode</span> <span class="fu">$</span> \hnd <span class="ot">-&gt;</span>
        withFile <span class="st">&quot;path/to/file1&quot;</span> <span class="dt">ReadMode</span> <span class="fu">$</span> \hnd1 <span class="ot">-&gt;</span>
            withFile <span class="st">&quot;path/to/file2&quot;</span> <span class="dt">ReadMode</span> <span class="fu">$</span> \hnd2 <span class="ot">-&gt;</span> <span class="kw">do</span>
                hGetContents hnd  <span class="fu">&gt;&gt;=</span> hPutStr hnd2
                hGetContents hnd1 <span class="fu">&gt;&gt;=</span> hPutStr hnd2</code></pre></div>
<p>Уже не так красиво. Хорошо, можно накидать волшебную стейт-монаду содержащую хэндлеры финализирующие действия аллоцирующие ресурсы.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    runMagicState <span class="fu">$</span> <span class="kw">do</span>
        hnd  <span class="ot">&lt;-</span> smartFileOpen <span class="st">&quot;path/to/file&quot;</span>  <span class="dt">ReadMode</span>
        hnd1 <span class="ot">&lt;-</span> smartFileOpen <span class="st">&quot;path/to/file1&quot;</span> <span class="dt">ReadMode</span>
        hnd2 <span class="ot">&lt;-</span> smartFileOpen <span class="st">&quot;path/to/file2&quot;</span> <span class="dt">ReadMode</span>
        liftIO <span class="fu">$</span> hGetContents hnd  <span class="fu">&gt;&gt;=</span> hPutStr hnd2
        liftIO <span class="fu">$</span> hGetContents hnd1 <span class="fu">&gt;&gt;=</span> hPutStr hnd2</code></pre></div>
<p>Можно сделать так чтобы смарт-конструкторы возвращали ещё и универсальный ключ, добавить подсчёт ссылок, передавать ресурсы между тредами, освобождать в рантайме и вообще сделать свой собственный <a href="http://hackage.haskell.org/package/resourcet">resourcet</a>. Правда придётся писать для всех ресурсов смарт-конструкторы регистрирующие финализаторы, которые можно использовать только с волшебной монадой, что немного расстраивает. А можно решить что во варианте с <code>withFile</code> итак всё было хорошо кроме способа соединения вычислений между собой и поискать тут монаду более хитрую монаду.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">newtype</span> <span class="dt">Managed</span> a <span class="fu">=</span> <span class="dt">Managed</span> {<span class="ot"> with ::</span> forall r <span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> <span class="dt">IO</span> r }

    <span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Managed</span> <span class="kw">where</span>
        fmap f mx <span class="fu">=</span> <span class="dt">Managed</span> <span class="fu">$</span> \return_ <span class="ot">-&gt;</span>
            with mx <span class="fu">$</span> \x <span class="ot">-&gt;</span>
            return_ <span class="fu">$</span> f x

    <span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Managed</span> <span class="kw">where</span>
        pure r    <span class="fu">=</span> <span class="dt">Managed</span> <span class="fu">$</span> \return_ <span class="ot">-&gt;</span> return_ r

        mf <span class="fu">&lt;*&gt;</span> mx <span class="fu">=</span> <span class="dt">Managed</span> <span class="fu">$</span> \return_ <span class="ot">-&gt;</span>
            with mf <span class="fu">$</span> \f <span class="ot">-&gt;</span>
            with mx <span class="fu">$</span> \x <span class="ot">-&gt;</span>
            return_ <span class="fu">$</span> f x

    <span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Managed</span> <span class="kw">where</span>
        return   <span class="fu">=</span> pure

        ma <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Managed</span> <span class="fu">$</span> \return_ <span class="ot">-&gt;</span>
            with ma <span class="fu">$</span> \a <span class="ot">-&gt;</span>
            with (f a) <span class="fu">$</span> \b <span class="ot">-&gt;</span>
            return_ b

    <span class="kw">instance</span> <span class="dt">MonadIO</span> <span class="dt">Managed</span> <span class="kw">where</span>
        liftIO m <span class="fu">=</span> <span class="dt">Managed</span> <span class="fu">$</span> \return_ <span class="ot">-&gt;</span> <span class="kw">do</span>
            v <span class="ot">&lt;-</span> m
            return_ v</code></pre></div>
<p>В принципе это примерно весь код, который необходим для работы <code>Managed</code>. Теперь можно писать код как-то так.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    with <span class="fu">$</span> <span class="kw">do</span>
        hnd  <span class="ot">&lt;-</span> <span class="dt">Managed</span> <span class="fu">$</span> withFile <span class="st">&quot;path/to/file&quot;</span> <span class="dt">ReadMode</span>
        hnd1 <span class="ot">&lt;-</span> <span class="dt">Managed</span> <span class="fu">$</span> withFile <span class="st">&quot;path/to/file1&quot;</span> <span class="dt">ReadMode</span>
        hnd2 <span class="ot">&lt;-</span> <span class="dt">Managed</span> <span class="fu">$</span> withFile <span class="st">&quot;path/to/file2&quot;</span> <span class="dt">ReadMode</span>
        liftIO <span class="fu">$</span> hGetContents hnd  <span class="fu">&gt;&gt;=</span> hPutStr hnd2
        liftIO <span class="fu">$</span> hGetContents hnd1 <span class="fu">&gt;&gt;=</span> hPutStr hnd2</code></pre></div>
<p>Плюсом данного подхода является использование готовых смарт-конструкторов, написанных автором библиотеки, отсутствие явного стейта, который можно было бы как-то хитро сломать и простота кода. Минусом скромность возможностей: нельзя передать ресурс во владение другому треду, нельзя запустить финализацию раньше времени<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Примерно как <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> в C++.</p>
<h2 id="monadcatch-и-monadmask">MonadCatch и MonadMask</h2>
<p>Наступило счастье? Скорее всего нет. В реальной жизни почти всегда почему-то недостаточно дёрнуть финализатор перед смертью. Ситуаций где это достаточно и необходимо станет совсем не много. Если начать задумываться о том что в ходе выполнения программы возникают исключения, то почему-то сразу начинает требоваться ловить эти исключения и передавать в другой тред, откладывать исключения до момента пока не закончится вон та очень важная операция и многое другое, типа таймеров, юзер-интерапта и прочего <code>KillThread</code>. Также очень часто приходится работать не с одной монадой, а со стеком монадных трансформеров. Трансформер на вершине стека не зависит от конкретной монады нижнего уровня и опирается лишь на констрейнты, которыми он её ограничивает. Итого: нужно обрабатывать исключения в рамках <code>Managed</code>, а не только вызывать финализацию, нужны инстансы <code>MonadCatch</code> и <code>MonadMask</code> для <code>Managed</code>. А вот тут возникают проблемы.</p>
<ul>
<li><p>В числе законов <code>MonadCatch</code> указан только:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">catch (throwM e) f <span class="fu">=</span> f e</code></pre></div>
<p>который выполнить довольно легко, но если не обеспечить также поведение вида:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">catch (try meval) f <span class="fu">&gt;&gt;</span> throwM e <span class="fu">=</span> throwM e</code></pre></div>
<p>то скорее всего люди столкнувшись с таким <code>catch</code>’ем будут озадачены настолько что отрубят автору такого инстанса руки. Но для <code>Managed</code> следующее связанное выражение выполняется не после текущего, а внутри. Так что если обернуть его целиком в <code>catch</code>, то мы заодно обернём в <code>catch</code> и все последующие связанные выражения в этой монаде и получится что-то вроде такого поведения.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">catch (try meval) f <span class="fu">&gt;&gt;</span> throwM e <span class="fu">=</span> f e</code></pre></div></li>
<li><p>Если оборачивать в <code>catch</code> <code>Managed</code>-выражение, должны быть перехвачены исключение возникшие только до следующего связывания или в финализаторе тоже?</p></li>
</ul>
<p>Можно попытаться вспомнить что <code>Managed</code>, это в теории такой специализированный вид монады <code>ContT</code> из <a href="http://hackage.haskell.org/package/transformers">transfomers</a>, а в <a href="http://hackage.haskell.org/package/exceptions">exceptions</a> есть необходимые инстансы для стандартных монад. Но если посмотреть туда, станет понятно что <code>ContT</code> чуть ли не единственная монада оттуда для которой Эдвард Кметт не придумал <code>MonadCatch</code> и <code>MonadMask</code>. В общем случае решить эти вопросы довольно трудно, традиционно принято их не решать вообще и пользоваться либо <a href="http://hackage.haskell.org/package/managed">managed</a>, либо <a href="http://hackage.haskell.org/package/exceptions">exceptions</a>.</p>
<h2 id="костыли">Костыли</h2>
<p>Что делать если очень хочется? Для начала попробуем себя уговорить, что проблемы нет. Начнём со второго вопроса. Итак, по сути каждое вычисление в <code>Managed</code> состоит из самого «вычисления» и некоего «финализатора», который выполнится после того как выполнятся все связанные вычисления.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="dt">Managed</span> <span class="fu">$</span> \следующее <span class="ot">-&gt;</span> вычисление <span class="fu">&gt;&gt;=</span> следующее <span class="fu">&gt;&gt;</span> финализатор</code></pre></div>
<p>Традиционный <code>withSome</code> выглядит примерно так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    withSome eval <span class="fu">=</span> bracket
        resourceInitialize
        (\resource <span class="ot">-&gt;</span> finalize resource)
        (\resource <span class="ot">-&gt;</span> eval resource)</code></pre></div>
<p>При таком подходе финализация вообще замаскирована от любых исключений. Даже если он реализован иначе, то всё же стоит думать что автор не дурак и написал смарт-конструктор с безопасным финализатором, раз уж решено пользоваться им. Потому что если это не так, то вместо него стоило бы написать свой. Таким образом исключения могут возникнуть только внутри «вычисления».</p>
<p>Хорошо. Как в таком случае обернуть в <code>catch</code> только половину функции, которая соответствует только нашему «вычислению»? Наверное никак. Но вместо этого мы можем попробовать инвалидировать финализатор.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE Rank2Types #-}</span>

<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Control.Exception</span> ( allowInterrupt )
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.IORef</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.Catch</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.Managed</span></code></pre></div>
<p>Чтобы быть <code>MonadCatch</code>, надо сначала стать <code>MonadThrow</code>. Но тут всё очевидно.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">MonadThrow</span> <span class="dt">Managed</span> <span class="kw">where</span>
<span class="fu">&gt;</span>     throwM <span class="fu">=</span> liftIO <span class="fu">.</span> throwM</code></pre></div>
<p>Затем изобразим функцию <code>catch</code> для типов, которые скрывает <code>Managed</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> managedCatch ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> ((a <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> <span class="dt">IO</span> r
<span class="fu">&gt;</span> managedCatch eval handler next <span class="fu">=</span> <span class="kw">do</span>
<span class="fu">&gt;</span>     ref <span class="ot">&lt;-</span> newIORef handler
<span class="fu">&gt;</span>     <span class="kw">let</span> handler&#39; e n <span class="fu">=</span> readIORef ref <span class="fu">&gt;&gt;=</span> \h <span class="ot">-&gt;</span> h e n
<span class="fu">&gt;</span>     catch (eval (\v <span class="ot">-&gt;</span> mask_ (writeIORef ref (\e _ <span class="ot">-&gt;</span> throwM e)) <span class="fu">&gt;&gt;</span> next v)) (\e <span class="ot">-&gt;</span> handler&#39; e next)</code></pre></div>
<p>Ну и сам инстанс будет выглядеть как-то так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">MonadCatch</span> <span class="dt">Managed</span> <span class="kw">where</span>
<span class="fu">&gt;</span>     catch eval handler <span class="fu">=</span> managed <span class="fu">$</span> managedCatch (with eval) (with <span class="fu">.</span> handler)</code></pre></div>
<p>Всё. Можно перехватывать и обрабатывать исключения. У этого подхода есть как минимум следующие недостатки:</p>
<ul>
<li>Нужна целая одна переменная. Кметту можно даже не пытаться показывать — проклянёт.</li>
<li>Всё вычисления от момента использования <code>catch</code> и до последнего связанного выражения на самом деле завёрнуто в <code>catch</code>, а если их несколько штук к ряду то на самом деле это матрёшка. И тут возникает нюанс: я точно не знаю как устроена обработка исключений в ghc, но все известные мне реализации <code>catch</code> подразумевают если и не копирование всего стека перед вхождением <code>catch</code>, то хотя бы его заморозку. Иначе не получится вернутся к состоянию стека до вызова <code>catch</code>. В общем случае это значит, что часть объектов на стеке будут удерживаться даже если бы в любом другом случае их собрал gc. Здесь же это удерживание будет продолжаться дольше чем надо вплоть до самого конца региона. Это проблема. Но с другой стороны это проблема не только данного решения, но и функций <code>withSomeThing</code> вообще так что хрен с ним.</li>
<li>Если асинхронное исключение прилетит после того после того как завершилось «вычисление», но до того как отработает маскировка, будет вызван оригинальный обработчик исключения, который сделает что-то. Беда-огорчение.</li>
</ul>
<p>Этот уровень можно считать условно пройденным. Дальше <code>MonadMask</code> и с ним всё хуже.</p>
<p>Попробуем понять, что должна делать и чего делать не должна функция <code>mask</code> для <code>Managed</code>. Видимо исходя из предположения в начале она должна маскировать «вычисление» и не маскировать «финализатор». Почему нужно не маскировать «финализатор»?</p>
<ul>
<li>Чтобы создать гомогенность поведения и не порождать неожиданных эффектов в конце выполняемого блока <code>catch</code> не ловит исключения в «финализаторе», а <code>mask</code> не маскирует «финализатор».</li>
<li>Для безопасности. Мы снова возвращаемся к тому вопросу, что «финализатор» написан человеком, который представляет себе как надо выделять и освобождать ресурс. Вероятнее всего он уже замаскирован, но если это не так, то для этого скорее всего были веские причины.</li>
</ul>
<p>Проблема в том, что <code>mask</code> маскирует функцию, а с точки зрения кода «вычисление» и «финализатор» это одна функция и замаскировать её мы можем только целиком. Хорошо, расчехляем <code>allowInterrupt</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> managedMask ::</span> ((forall b<span class="fu">.</span> <span class="dt">Managed</span> b <span class="ot">-&gt;</span> <span class="dt">Managed</span> b) <span class="ot">-&gt;</span> <span class="dt">Managed</span> a) <span class="ot">-&gt;</span> <span class="dt">Managed</span> a
<span class="fu">&gt;</span> managedMask eval <span class="fu">=</span>
<span class="fu">&gt;</span>     managed <span class="fu">$</span> \next <span class="ot">-&gt;</span>
<span class="fu">&gt;</span>         mask <span class="fu">$</span> \unmask <span class="ot">-&gt;</span>
<span class="fu">&gt;</span>             with (eval <span class="fu">$</span> managedRestore unmask) <span class="fu">$</span> \resource <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="fu">&gt;</span>                 v <span class="ot">&lt;-</span> unmask (next resource)
<span class="fu">&gt;</span>                 allowInterrupt
<span class="fu">&gt;</span>                 return v

<span class="fu">&gt;</span><span class="ot"> managedRestore ::</span> (forall a<span class="fu">.</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">Managed</span> b <span class="ot">-&gt;</span> <span class="dt">Managed</span> b
<span class="fu">&gt;</span> managedRestore oldRestore eval <span class="fu">=</span> managed <span class="fu">$</span> \next <span class="ot">-&gt;</span> oldRestore <span class="fu">$</span> with eval next</code></pre></div>
<p>Всё? Нет. Нужен ещё <code>uninterruptibleMask</code>. Он понятное дело выглядит абсолютно аналогично предыдущему коду, но есть одно но: <code>allowInterrupt</code> не производит никакого эффекта будучи вызванным из <code>uninterruptibleMask</code>. Другого способа размаскировать «финализатор» я не знаю и если по какой-то причине он зависнет то это уже навсегда. Кроме того это создаёт ощутимую разницу с <code>mask</code> в поведении. Что делать?</p>
<ul>
<li>Гомогенезировать поведение. Разрешить <code>mask</code> маскировать «финализатор», a <code>catch</code> ловить исключения в финализаторе. Это не сложно, но я уверен что это не совсем то поведение, которое хотелось бы видеть.</li>
<li>Пойти на сомнительную сделку с собственной совестью и решить что <code>uninterruptibleMask</code> всё равно никто толком не использует примерно никогда, а если и использует то на коротких, гарантированно завершающихся функциях, у которых почти наверняка нет «финализатора».</li>
<li>Страдать и признать поражение и страдать.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">MonadMask</span> <span class="dt">Managed</span> <span class="kw">where</span>
<span class="fu">&gt;</span>     mask                <span class="fu">=</span> managedMask
<span class="fu">&gt;</span>     uninterruptibleMask <span class="fu">=</span>
<span class="fu">&gt;</span>         \eval <span class="ot">-&gt;</span> managed <span class="fu">$</span> \next <span class="ot">-&gt;</span>
<span class="fu">&gt;</span>             uninterruptibleMask <span class="fu">$</span> \unmask <span class="ot">-&gt;</span>
<span class="fu">&gt;</span>                 with (eval <span class="fu">$</span> managedRestore unmask) <span class="fu">$</span> (unmask <span class="fu">.</span> next)</code></pre></div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Также важным недостатком данной схемы является то что можно вернуть ресурс из блока кода после того как отработали все финализаторы и он в лучшем случае больше недоступен. Но во-первых насколько я понимаю эта проблема характерна и для resourcet-подобных решений, во-вторых это совсем другая долгая и печальная история.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Список реакци которые мне доводилось ставить</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-12-27-reaction-list.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-12-27-reaction-list.html</id>
    <published>2015-12-27T00:00:00Z</published>
    <updated>2015-12-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Вот что удалось вспомнить:</p>
<ol>
<li>Реакция Гриньяра</li>
<li>Металл-галлидный обмен</li>
<li>Реакция Габриэля</li>
<li>Реакция Анри</li>
<li>Гидрирование азидов с платиной на угле</li>
<li>Реакция азо-Виттега</li>
<li>Реакция Финкельштейна</li>
<li>Восстановление двойной связи боргидридом натрия</li>
<li>Восстановление иминов цианоборгидридом натрия</li>
<li>Прямое броммирование фенонов</li>
<li>Прямое броммирование замещённых электронодонорных ароматических соединений</li>
<li>Броммирование замещённых электронодонорных ароматических соединений NBS’ом</li>
<li>Алкилирование фенолов галогеналканами</li>
<li>Формилирование ароматических соединений по Вильсмайеру</li>
<li>Формилирование дихлорметилметиловым эфиром</li>
<li>Окисление спиртов по Сверну</li>
<li>Замещение алифатического галлогена на азид</li>
<li>Получение сложных эфиров прямой этерификацией</li>
<li>Ацилирование по Фриделю-Крафтцу</li>
<li>Получение алкенов дегидратированием спиртов</li>
<li>Реакция Мицунобу</li>
</ol>]]></summary>
</entry>
<entry>
    <title>О MskHUG в декабре 2015го года…</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-12-11-meetup.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-12-11-meetup.html</id>
    <published>2015-12-11T00:00:00Z</published>
    <updated>2015-12-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Сходил на слёт хаскелистов в Яндексе, послушал доклады. Коротко:</p>
<ul>
<li><p>Лучший доклад был пожалуй про Servant. Человек настолько задороно выступил, что мне захотелось оный Servant потыкать, хотя у меня и нет задач для которых мог бы понадобится веб-сервер. Чуваку, который сравнивал сложность комбинирования роутов веб-сервера и сложность комбинирования парсеров в parsec посылаю луч ненависти: во втором случае сложность вылезает из-за типично нетревиальных грамматик и того что парсек говно и не умеет в бэктрекинг (но это совсем другая история).</p></li>
<li><p>Наиболее полезным для меня оказался доклад про зависимые типы, который оказался не про зависимые типы, а про костыли в GHC, которые позволяют типизировать типы типами. Собственно я наконец примерно понял как работает этот механизм. А вот квантор <code>pi</code> мне напомнил С++14 с его <code>decltype(auto)</code>.</p></li>
<li><p>Зефиров опять рассказывал что-то очень интересное и я опять мало что смог вынести из доклада: во-первых опоздал к началу, во-вторых сам доклад проводился в экстремальных условиях и в-третьих Зефиров довольно хреновый докладчик.</p></li>
<li><p>Крайне полезным был доклад <span class="citation">@qnikst</span>’а. Жаль что он не успел его дочитать. Всё бы ничего, но мне как-то стабильно не нужно вызывать внешние функции из haskell руками. Обычно дело ограничивается сериализацией/десериализацией сишных структур прилетевших из ядерных интерфейсов. Хотя идея хакнуть рантайм через unsafe ffi-вызовы, которые блокируют тред и gc мне показалась очень интересной, хотя и вредной.</p></li>
<li><p>Посмотрел на живого <del>Ленина</del><span class="citation">@qnikst</span>’а. Он классный <del>,от него сияние исходит</del>.</p></li>
<li><p>Попытался объяснить живому <span class="citation">@segfault</span>’у радость комбинатора неподвижной точки.</p></li>
<li><p>Попытался объяснить живому <span class="citation">@segfault</span>’у радость GREEN’а, полнопрограмной компиляции и отказа от стека в пользу распихивания аргументов функций по фиксированным непересекающимся регистрам.</p></li>
</ul>
<p>Больше не сделал ничего ползного. В следующий раз нужно будет запастись:</p>
<ul>
<li><p>Бейджем с ником на жуйке.</p></li>
<li><p>Карточками с вопросами, чтобы передавать их по кругу по столу во время неформальной части.</p></li>
<li><p>Докладом про Remote Monad, если к этому времени мой <code>Action</code> будет честным частным случаем.</p></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Список книг которые надо прочитать</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-11-09-books.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-11-09-books.html</id>
    <published>2015-11-09T00:00:00Z</published>
    <updated>2015-11-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="мне">Мне</h3>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/Выкрикивается_лот_49">Выкрикивается лот 49 (1966)</a></li>
<li><dl>
<dt>Дневник одного гения (1964)</dt>
<dd>Сальвадор Дали
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Лето,_прощай!">Лето, прощай! (2006)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/451_градус_по_Фаренгейту">451°F (1953)</a></li>
<li>Уснувший в Армагеддоне (1948)</li>
<li>Все лето в один день (1959)</li>
<li><a href="https://ru.wikipedia.org/wiki/Из_праха_восставшие">Из праха восставшие (2001)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Смерть_—_дело_одинокое">Смерть — дело одинокое (1985)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Американский_психопат_(роман)">Американский психопат (1991)</a></li>
<li><dl>
<dt>Автокатастрофа (1973)</dt>
<dd>роман Джеймса Балларда
</dd>
</dl></li>
<li><dl>
<dt>Бетонный остров (1974)</dt>
<dd>роман Джеймса Балларда
</dd>
</dl></li>
<li><dl>
<dt>Высотка (1975)</dt>
<dd>роман Джеймса Балларда
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Бесконечная_история_(повесть)">Бесконечная история (1979)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Процесс_(роман)">Процесс (1925)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Мы_(роман)">Мы (1924)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Мечтают_ли_андроиды_об_электроовцах?">Мечтают ли андроиды об электроовцах? (1968)</a></li>
<li>Око небесное (1957)</li>
<li><a href="https://ru.wikipedia.org/wiki/Убик">Убик (1969)</a></li>
<li>Лабиринт смерти (1970)</li>
<li>Три стигмата Палмера Элдрича (1964)</li>
<li><a href="https://en.wikipedia.org/wiki/VALIS">ВАЛИС (1981)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Помутнение">Помутнение (1977)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Команда_корректировки">Команда корректировки (1954)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Мы_вам_всё_припомним">Мы вам всё припомним (1966)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Radio_Free_Albemuth">Свободное радио Албемута (1976)</a></li>
</ul>
<h3 id="всем">Всем</h3>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/Степной_волк_(роман)">Степной волк (1927)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Сиддхартха_(роман)">Сидхартха (1922)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/1984_(роман)">1984 (1948)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/О_дивный_новый_мир">О дивный новый мир (1932)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Маятник_Фуко_(роман)">Маятник Фуко (1988)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Невыносимая_лёгкость_бытия">Невыносимая лёгкость бытия (1984)</a></li>
<li>Циники (1928)</li>
<li><a href="https://ru.wikipedia.org/wiki/Волшебник_Земноморья">Волшебник Земноморья (1968)</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>О скоупах</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-08-02-scope.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-08-02-scope.html</id>
    <published>2015-08-02T00:00:00Z</published>
    <updated>2015-08-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>А вот ещё одна хитрая задачка. Положим у нас есть несколько устройств, которые мы можем как-то дёргать через <code>DevHnd a</code> (где <code>a</code> — тип-параметр характеризующий устройство). Проблема в том, что если два треда будут рулить устройством одновременно, то результат будет трудно предсказать. Хорошо, вводим концепцию владения устройством: управлять устройством<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> можно только завладев им, если кто-то другой завладел устройством до тебя, то ты ждёшь пока устройство освободится. Просто, но есть пара нюансов:</p>
<ul>
<li>мы говорим «блокировка» и подразумеваем «дедлок», поскольку в реальной жизни тред должен контролировать состояние более одного устройства одновременно;</li>
<li>из типа <code>DevHnd a</code> никак не следует захвачен ли он текущим тредом, а значит проверка этого факта будет осуществляться в рантайме каждый раз когда мы будем модифицировать устройство и более того время от времени мы будем сталкиваться с ошибками времени исполнения.</li>
</ul>
<p>В общем случае, когда устройства захватываются и высвобождаются в произвольный момент времени ни первую, ни вторую проблему мы вероятнее всего не решим. Но если рассмотреть ситуацию когда все устройства захватываются и освобождаются одновременно ситуация перестаёт быть такой удручающей и внезапно укладывается в традиционный для haskell’я паттерн:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> c
    withSomething dev1 dev2 action <span class="fu">=</span> <span class="kw">do</span>
        alloc dev1 dev2
        v <span class="ot">&lt;-</span> action
        dealloc dev1 dev2
        return v</code></pre></div>
<p>Способов заблокировать несколько сущностей одновременно избежав дедлоков более одного, выберите по вкусу. Но <code>action</code> всё равно может содержать действия с устройствами, которые мы не захватили. Чтобы этого избежать можно сделать следующее:</p>
<ul>
<li>введём изоморфный <code>DevHnd a</code> тип <code>StaticHnd s a</code> с фантомным параметром <code>s</code> и приватную функцию <code>toStatic</code> делающую из первого второе;</li>
<li>введём изоморфную <code>IO a</code> монаду <code>Scope a</code>, а также функции для управления устройствами внутри этой монады через <code>StaticHnd s a</code>;</li>
<li>перепишем предыдущий код так:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c
    withSomething dev1 dev2 action <span class="fu">=</span> <span class="kw">do</span>
        alloc dev1 dev2
        v <span class="ot">&lt;-</span> action (toStatic dev1) (toStatic dev2)
        dealloc dev1 dev2
        return v</code></pre></div>
<p>Всё. Теперь следим за руками:</p>
<ul>
<li>изменять в нашем скоупе устройства через <code>DevHnd a</code> мы не можем, поскольку соответствующий мутатор не определён для <code>Scope a</code>;</li>
<li>создать <code>StaticHnd s a</code> мы можем только при помощи <code>withSomething</code>, поскольку <code>toStatic</code> не экспортирован наружу;</li>
<li>вернуть <code>StaticHnd s a</code> из <code>action</code> мы тоже не можем, поскольку функция не может вернуть значение любого типа, а фантомный параметр <code>s</code> передаваемых в неё аргументов объявлен как <code>forall</code>.</li>
</ul>
<p>Из всего этого следует что любая попытка использовать внутри нашего скоупа не захваченное устройство или устройство захваченное в другой скоуп (кроме родительского :^)) завершится <strong>ошибкой компиляции</strong>. Хорошо? Очень хорошо. Но на этом хорошее заканчивается и начинается Real World.</p>
<p>Приведённый код определён для двух устройств захватываемых в скоуп. Очевидным образом это довольно частный случай и этого мало. Также очевидно что функция <code>withSomething</code> содержит детали приватной реализации и должна быть чёрным ящиком. Есть несколько вариантов решения:</p>
<ul>
<li><p>Наиболее распространённым решением таких проблем в haskell’е это… унылая копипаста в результате которой получатся функции вида:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c

<span class="ot">withSomething2 ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c

<span class="ot">withSomething3 ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> c <span class="ot">-&gt;</span>
    (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s c <span class="ot">-&gt;</span> <span class="dt">Scope</span> d) <span class="ot">-&gt;</span> <span class="dt">IO</span> d</code></pre></div>
<p>И так до тех пор пока не надоест.</p></li>
<li><p>Также можно попробовать изобразить композицию.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">action <span class="fu">=</span>
    withSomething hnd1 <span class="fu">$</span> \sHnd1 <span class="ot">-&gt;</span>
        withSomething hnd2 <span class="fu">$</span> \sHnd2 <span class="ot">-&gt;</span>
            withSomething hnd3 <span class="fu">$</span> \sHnd3 <span class="ot">-&gt;</span> <span class="kw">do</span>
                doSomething sHnd1
                doSomething sHnd2
                doSomething sHnd3</code></pre></div>
<p>Но так мы теряем возможность захватывать устройства одной транзакцией (у каждого <code>withSomething</code> своя транзакция). В принципе это можно пофиксить введя ещё одну стадию заправки ракеты:</p>
<ul>
<li>вводим ещё одну монаду<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> (например Accure a) внутри которой можно делать только withSomething и run;</li>
<li>withSomething просто добавляет захват очередного устройства в готовящуюся транзакцию;</li>
<li>run запускает транзакцию и затем выполняет наш Scope.</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    action <span class="fu">=</span> accure <span class="fu">$</span>
        withSomething hnd1 <span class="fu">$</span> \sHnd1 <span class="ot">-&gt;</span>
            withSomething hnd2 <span class="fu">$</span> \sHnd2 <span class="ot">-&gt;</span>
                withSomething hnd3 <span class="fu">$</span> \sHnd3 <span class="ot">-&gt;</span> run <span class="fu">$</span> <span class="kw">do</span>
                    doSomething sHnd1
                    doSomething sHnd2
                    doSomething sHnd3</code></pre></div>
<ul>
<li><p>Наконец есть магия в стиле <code>Applicative</code> позволяющая писать что-то в духе:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(\v1 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1
(\v1 v2 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1 <span class="fu">&lt;*&gt;</span> doSome2
(\v1 v2 v3 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1 <span class="fu">&lt;*&gt;</span> doSome2 <span class="fu">&lt;*&gt;</span> doSome3</code></pre></div>
<p>Я даже видел как что-то подобное использовали в parsec’е, но от попыток натянуть это на свои типы у меня стабильно плавится мозг.</p></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>В данном случае это не так принципиально, но под управлением устройством разумеется подразумевается изменение его состояния.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Если у вас монада головного мозга конечно. Достаточно моноида, же.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Список фильмов которые надо посмотреть или пересмотреть</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-02-17-films.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-02-17-films.html</id>
    <published>2015-02-17T00:00:00Z</published>
    <updated>2015-02-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="пересмотреть-или-показать">Пересмотреть или показать</h3>
<ul>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Нирвана_(фильм,_1997)">Нирвана (1997)</a></dt>
<dd>Длительность: 113 мин
</dd>
<dd>Молодой Кристофер Ламберт, наркотики, безысходность, уши Гибсона торчащие из каждого угла, всё кончается очень сомнительно. Что ещё надо-то для счастья? Наверное то что хороших фильмов в декорациях киберпанка очень немного и этот я вспоминаю раньше чем того же «Джонни-Мнемоника», например.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Чернокнижник">Чернокнижник (1989)</a></dt>
<dd>Длительность: 102 мин
</dd>
<dd>Ещё один фильм атмосферу которого можно резать ножом и кушать ложкой. Злой, очень злой, Джулиан Ассандж творит на экране всё что хочет: вступает в сношения с дьяволом, летает, калечит людей, убивает детей. Испуганные или на глухо долбанутые люди пытаются ему противостоять при помощи посыпания поваренной солью и забивания железного гвоздя в след. Они всё это делают зачем-то, но это всё абсолютно не имеет значения и не мешает сосредоточится на том что действительно важно. На чистом зле.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Шестиструнный_самурай">Шестиструнный самурай (1998)</a></dt>
<dd>Длительность: 91 минут
</dd>
<dd>Не стоит смотреть: тем кому за державу обидно
</dd>
<dd>Что делать если денег катастрофически не хватает, есть только друзья музыканты, а кино снимать очень хочется? Ну, в России у вас может выйти мрачноватая история о бандитах, которая станет культовой, а вы — очень известным режисёром. А в Америке у вас выйдет задорный треш, вы провалитесь в прокате и по большому счёту не снимете больше ничего. Но зато какой выйдет треш! Это как экранизация Фолаута, только без футуризма, силовой брони, но зато с канибалами, солдатами Красной Армии и дуэлью со Смертью на гитарах.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Весна,_лето,_осень,_зима…_и_снова_весна">Весна, лето, осень, зима… и снова весна (2003)</a></dt>
<dd>При том что фильм на корейском, он отлично смотрится без перевода, что само по себе уже любопытно. И ничего не поделаешь, но это Ким Ки Дук.
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Синяя_птица_(мультфильм)">Синяя птица (1970)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Мёбиус_(фильм,_1996)">Мёбиус (1996)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Тринадцатый_этаж">Тринадцатый этаж (1999)</a></dt>
<dd>Это как Матрица, но без акрабатики, перестрелок, спецэффектов и гораздо смелее по своей идее.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Тёмный_город_(фильм,_1998)">Тёмный город (1998)</a></dt>
<dd>Это как Матрица, но без компьютеров с инопланетянами и гораздо мрачнее. Можно смотреть хотя бы из-за атмосферы нуара.
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Кот_раввина">Кот раввина (2011)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Хранители_(фильм)">Хранители (2009)</a></dt>
<dd>«…Когда скопившиеся грязь похоти и убийств вспенится им до пояса, все шлюхи и политиканы посмотрят вверх и возопят: “Спаси нас!”, а я прошепчу: “НЕТ”…»
</dd>
</dl></li>
<li><dl>
<dt>Престиж (2007)</dt>
<dd>Лучший фильм Кристофера Нолана и один из лучших фильмов вообще, прекрасные актёры, прекрасный Дэвид Боуи.
</dd>
</dl></li>
<li><dl>
<dt>Даун Хаус (2001)</dt>
<dd>«…— Это не заело. Это хаус. В моем противоречивом прошлом — молодёжная эстрада…»
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Страх_и_ненависть_в_Лас-Вегасе">Страх и ненависть в Лас (1998)</a> и <a href="https://ru.wikipedia.org/wiki/В_отрыв!">В отрыв! (1999)</a></dt>
<dd>Два наиболее объективных фильма про наркотики из тех что я знаю. Персонажи не садятся в тюрьму, им не отпиливают руку, они не занимаются проституцией за наркотики. С ними вообще объективно не происходит ничего плохого или хорошего. Примерно как и бывает в жизни.
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Бешеные_псы">Бешеные псы (1992)</a> и <a href="https://ru.wikipedia.org/wiki/Криминальное_чтиво">Криминальное чтиво (1994)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Лабиринт_(фильм)">Лабиринт (1986)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Догвилль">Догвилль (2003)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Антихрист_(фильм,_2009)">Антихрист (2009)</a></dt>
<dd>Не стоит смотреть: никому
</dd>
<dd>Это было очень тяжёлое и плохое путешествие. Теперь, когда мне говорят о Ларсе фон Триере я вспоминаю именно это. Но возможно я хочу этим с кем-то поделиться.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Голод_(фильм,_1983)">Голод (1983)</a></dt>
<dd>Длительность: 97 минут
</dd>
</dl></li>
</ul>
<h3 id="посмотреть">Посмотреть</h3>
<ul>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Преследование_(фильм,_1998)">Преследование (1998)</a></dt>
<dd>фильм Кристофера Нолана
</dd>
</dl></li>
<li><dl>
<dt>Интерстеллар (2014)</dt>
<dd>фильм Кристофера Нолана
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Одержимая_(фильм,_1981)">Одержимая (1981)</a></dt>
<dd>фильм Анджея Жулавского
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Шаманка_(фильм)">Шаманка (1996)</a></dt>
<dd>фильм Анджея Жулавского
</dd>
</dl></li>
<li>Восход Люцифера (1980)</li>
<li>Пробуждение моего демонического брата (1969)</li>
<li>Торжественное открытие храма наслаждений (1954)</li>
<li>Трудно быть богом (2013)</li>
<li>Жидкое небо (1983)</li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Обед_нагишом_(фильм)">Обед нагишом (1991)</a></dt>
<dd>Длительность: 115 мин
</dd>
<dd>Кроненберг
</dd>
</dl></li>
<li>Вход в пустоту (2009)</li>
<li>Помутнение (2006)</li>
<li><a href="https://ru.wikipedia.org/wiki/Мертвец_(фильм)">Мертвец (1995)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Tamala_2010:_A_Punk_Cat_in_Space">Tamala 2010: A Punk Cat in Space (2007)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Код_46">Код 46 (2003)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Страх_темноты">Страх темноты (2007)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Выживут_только_любовники">Выживут только любовники (2013)</a></li>
<li>Баба Яга (1973)</li>
<li><a href="https://ru.wikipedia.org/wiki/Экзистенция_(фильм)">Экзистенция (1999)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Печальная_баллада_для_трубы">Печальная баллада для трубы (2010)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Железное_небо">Железное небо (2012)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Двойник_(фильм,_2013)">Двойник (2013)</a></dt>
<dd>экранизация Достоевского
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Временная_петля_(фильм,_2007)">Временная петля (2007)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Омерзительная_восьмёрка">Омерзительная восьмёрка (2016)</a></dt>
<dd>фильм Квентина Тарантино
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Джанго_освобождённый">Джанго освобождённый (2012)</a></dt>
<dd>фильм Квентина Тарантино
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Бесславные_ублюдки">Бесславные ублюдки (2009)</a></dt>
<dd>фильм Квентина Тарантино
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Доказательство_смерти">Доказательство смерти (2007)</a></dt>
<dd>фильм Квентина Тарантино
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Джеки_Браун">Джеки Браун (1997)</a></dt>
<dd>фильм Квентина Тарантино
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Мандерлей">Мандерлей (2005)</a></dt>
<dd>фильм Ларса фон Триера
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Танцующая_в_темноте">Танцующая в темноте (2000)</a></dt>
<dd>фильм Ларса фон Триера ну и Бьорк на экране
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Нимфоманка_(фильм)">Нимфоманка (2013)</a></dt>
<dd>фильм Ларса фон Триера
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Ребёнок_Розмари">Ребёнок Розмари (1968)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/THX_1138">THX 1138 (1971)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Последнее_искушение_Христа">Последнее искушение Христа (1988)</a></dt>
<dd>Длительность: 164 минут
</dd>
<dd>Самое время пересмотреть фильмографию Дэвида Боуи. Ну и Скорсезе.
</dd>
</dl></li>
<li><dl>
<dt>Gutterdämmerung (2016)</dt>
<dd>Совершенно непонятно о чём идёт речь и будет ли это записано на киноплёнку, но хочу.
</dd>
</dl></li>
</ul>
<h3 id="попробовать-посмотреть">Попробовать посмотреть</h3>
<ul>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/На_серебряной_планете">На серебряной планете (1987)</a></dt>
<dd>фильм Анджея Жулавского
</dd>
</dl></li>
<li>Святая гора (1973)</li>
<li>Святая кровь (1989)</li>
<li>Другие ипостаси (1980)</li>
<li><a href="https://ru.wikipedia.org/wiki/Тупик_(фильм,_1970)">Тупик (1970)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Кунг_Фьюри">Кунг Фьюри (2015)</a></li>
<li><a href="https://en.wikipedia.org/wiki/It&#39;s_Such_a_Beautiful_Day_(film)">It’s Such a Beautiful Day (2012)</a></li>
<li><a href="https://ru.wikipedia.org/wiki/Мне_скучно,_бес">Мне скучно, бес (1993)</a></li>
<li><dl>
<dt>Иерей-сан (2015)</dt>
<dd>сценарий Охлабыстина
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Соловей-Разбойник_(фильм)">Соловей-Разбойник (2012)</a></dt>
<dd>сценарий Охлабыстина
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Арбитр_(фильм)">Арбитр (1992)</a></dt>
<dd>сценарий Охлабыстина
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Урод_(фильм)">Урод (1993)</a></dt>
<dd>сценарий Охлабыстина
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Мусорщик">Мусорщик (2001)</a></dt>
<dd>сценарий Охлабыстина
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Кто_я">Кто я (2014)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Бёрдмэн">Бёрдмэн (2014)</a></dt>
<dd>Майкл Китон играет Майкла Китона
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Меланхолия_(фильм,_2011)">Меланхолия (2011)</a></dt>
<dd>фильм Ларса фон Триера
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Рассекая_волны">Рассекая волны (1996)</a></dt>
<dd>фильм Ларса фон Триера
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Перекрёсток_Миллера">Перекрёсток Миллера (1990)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Человек,_который_упал_на_Землю">Человек, который упал на Землю (1976)</a></dt>
<dd>Длительность: 138 мин
</dd>
<dd>Самое время пересмотреть фильмографию Дэвида Боуи.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Счастливого_Рождества,_мистер_Лоуренс">Счастливого Рождества, мистер Лоуренс (1983)</a></dt>
<dd>Длительность: 124 мин
</dd>
<dd>Самое время пересмотреть фильмографию Дэвида Боуи.
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Супер">Супер (2010)</a></dt>
<dd>Длительность: 96 мин
</dd>
<dd>Треш от человека который умеет делать треш
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Стражи_Галактики_(фильм)">Стражи Галактики (2014)</a></dt>
<dd>Длительность: 121 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Письма_мёртвого_человека">Письма мёртвого человека (1986)</a></dt>
<dd>Длительность: 88 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Господин_оформитель">Господин оформитель (1988)</a></dt>
<dd>Длительность: 103 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Вельд_(фильм)">Вельд (1997)</a></dt>
<dd>Длительность: 81 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Луна_2112">Луна 2112 (2009)</a></dt>
<dd>Длительность: 97 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Мачете_(фильм)">Мачете (2010)</a></dt>
<dd>Длительность: 105 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Мачете_убивает">Мачете убивает (2013)</a></dt>
<dd>Длительность: 107 мин
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Бомж_с_дробовиком">Бомж с дробовиком (2011)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Город_грехов_(фильм)">Город грехов (2005)</a></dt>
<dd>Длительность: 124 или 142 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Достучаться_до_небес_(фильм)">Достучаться до небес (1997)</a></dt>
<dd>Длительность: 87 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Корпорация_«Бессмертие»_(фильм)">Корпорация «Бессмертие» (1992)</a></dt>
<dd>Длительность: 110 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Бегущий_по_лезвию">Бегущий по лезвию (1982)</a></dt>
<dd>Длительность: 117 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Плоть_и_кровь">Плоть и кровь (1985)</a></dt>
<dd>Длительность: 126 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Попутчик_(фильм,_1986,_США)">Попутчик (1986)</a></dt>
<dd>Длительность: 97 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Кровь_героев">Кровь героев (1989)</a></dt>
<dd>Длительность: 90 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Считанные_секунды">Считанные секунды (1992)</a></dt>
<dd>Длительность: 91 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Хеллбой_2:_Золотая_армия">Хеллбой 2: Золотая армия (2008)</a></dt>
<dd>Длительность: 115 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Крепость_(фильм,_1993)">Крепость (1993)</a></dt>
<dd>Длительность: 91 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Горец_3:_Последнее_измерение">Горец 3: Последнее измерение (1994)</a></dt>
<dd>Длительность: 99 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Беовульф_(фильм,_1999)">Беовульф (1999)</a></dt>
<dd>Длительность: 95 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Беовульф_(фильм,_2007)">Беовульф (2007)</a></dt>
<dd>Длительность: 113 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Из_машины">Из машины (2015)</a></dt>
<dd>Длительность: 108 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Чекист_(фильм)">Чекист (1992)</a></dt>
<dd>Длительность: 91 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Кочегар_(фильм)">Кочегар (2010)</a></dt>
<dd>Длительность: 87 мин
</dd>
<dd>Балобанов
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Про_уродов_и_людей">Про уродов и людей (1998)</a></dt>
<dd>Балобанов, Маковецкий, Сухоруков
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Я_тоже_хочу">Я тоже хочу (2012)</a></dt>
<dd>Длительность: 80 мин
</dd>
<dd>Балобанов
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/До_первой_крови">До первой крови (1989)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Счастливые_дни_(фильм,_1991)">Счастливые дни (1991)</a></dt>
<dd>Длительность: 82 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Замок_(фильм,_1994)">Замок (1994)</a></dt>
<dd>Длительность: 110 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Морфий_(фильм)">Морфий (2008)</a></dt>
<dd>Длительность: 112 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Боже,_благослови_Америку_(фильм,_2011)">Боже, благослови Америку (2011)</a></dt>
<dd>Длительность: 104 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Самый_лучший_папа">Самый лучший папа (2009)</a></dt>
<dd>Длительность: 99 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Американский_психопат_(фильм)">Американский психопат (2000)</a></dt>
<dd>Длительность: 102 мин
</dd>
</dl></li>
<li><dl>
<dt>Oh My God! (2012)</dt>
<dd>Длительность: 125 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Ведьма_(фильм,_2015)">Ведьма (2015)</a></dt>
<dd>Длительность: 90 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Любовь_(фильм,_2015)">Любовь (2015)</a></dt>
<dd>Длительность: 135 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Лобстер_(фильм)">Лобстер (2015)</a></dt>
<dd>Длительность: 118 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Глаза_звезды">Глаза звезды (2014)</a></dt>
<dd>Длительность: 98 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Гонгофер">Гонгофер (1992)</a></dt>
<dd>Длительность: 98 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Судороги_(фильм)">Судороги (1975)</a></dt>
<dd>Длительность: 87 мин
</dd>
<dd>Кроненберг
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Преступления_будущего">Преступления будущего (1970)</a></dt>
<dd>Длительность: 70 мин
</dd>
<dd>Кроненберг
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Бешенство_(фильм)">Бешенство (1977)</a></dt>
<dd>Длительность: 96 мин
</dd>
<dd>Кроненберг
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Выводок_(фильм)">Выводок (1979)</a></dt>
<dd>Длительность: 92 мин
</dd>
<dd>Кроненберг
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Опасный_метод">Опасный метод (2011)</a></dt>
<dd>Длительность: 99 мин
</dd>
<dd>Кроненберг
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Высотка">Высотка (2015)</a></dt>
<dd>Длительность: 119 мин
</dd>
<dd>экранизация Балларда
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Связанные_насмерть">Связанные насмерть (1988)</a></dt>
<dd>Длительность: 115 мин
</dd>
<dd>Кроненберг
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Муха_(фильм,_1986)">Муха (1986)</a></dt>
<dd>Длительность: 100 мин
</dd>
<dd>Кроненберг
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Муха_(фильм,_1958)">Муха (1958)</a></dt>
<dd>Длительность: 94 мин
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Видеодром">Видеодром (1983)</a></dt>
<dd>Длительность: 90 мин
</dd>
<dd>Кроненберг
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Сканнеры">Сканнеры (1981)</a></dt>
<dd>Длительность: 103 мин
</dd>
<dd>Кроненберг
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Экзистенция_(фильм)">Экзистенция (1999)</a></dt>
<dd>Длительность: 97 мин
</dd>
<dd>Кроненберг
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Автокатастрофа_(фильм)">Автокатастрофа (1996)</a></dt>
<dd>Длительность: 100 мин
</dd>
<dd>Кроненберг
</dd>
<dd>экранизация Балларда
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Космополис_(фильм)">Космополис (2012)</a></dt>
<dd>Кроненберг
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Бразилия_(фильм)">Бразилия (1985)</a></dt>
<dd>Длительность: 142 мин
</dd>
<dd>Терри Гиллиам
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Бандиты_времени">Бандиты времени (1981)</a></dt>
<dd>Длительность: 116 мин
</dd>
<dd>Терри Гиллиам
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Бармаглот_(фильм)">Бармаглот (1977)</a></dt>
<dd>Длительность: 105 мин
</dd>
<dd>Терри Гиллиам
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Теорема_Зеро">Теорема Зеро (2013)</a></dt>
<dd>Длительность: 107 мин
</dd>
<dd>Терри Гиллиам
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Король-рыбак_(фильм)">Король-рыбак (1991)</a></dt>
<dd>Длительность: 137 мин
</dd>
<dd>Терри Гиллиам
</dd>
</dl></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/Приключения_барона_Мюнхгаузена_(фильм)">Приключения барона Мюнхгаузена (1988)</a></dt>
<dd>Длительность: 127 мин
</dd>
<dd>Терри Гиллиам
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Отряд_самоубийц_(фильм,_2016)">Отряд самоубийц (2016)</a></li>
<li><dl>
<dt><a href="https://ru.wikipedia.org/wiki/1984_(фильм,_1984)">1984 (1984)</a></dt>
<dd>Длительность: 113 мин
</dd>
</dl></li>
<li><a href="https://ru.wikipedia.org/wiki/Свободное_радио_Альбемута_(фильм)">Свободное радио Альбемута (2010)</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Jolla</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-07-17-Jolla.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-07-17-Jolla.html</id>
    <published>2014-07-17T00:00:00Z</published>
    <updated>2014-07-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Jolla — это тот самый линукс-смартфон который мы все так ждали. Здесь всё как на десктопе: искоропки ничего не работает, накатываешь обновления — становится лучше, дорабатываешь напильником — получается худо-бедно что-то работоспособное. Зато масса удовольствия от напильника и общения с разработчиками, а также очень неплохая звонилка и таймерная служба искоропки.</p>
<!--more-->
<p>Впечатления от устройства самые противоречивые. Первое что бросается в глаза — это не Нокия. Ни тебе цельного корпуса из поликарбоната защищающего устройство от ударов, ни тебе AMOLED дисплея позволяющего без лишних затрат рисовать часы на заблокированном экране, ни тебе фрезеровки. В общем нет в нём искры гнева Божьего. Затем ты включаешь телефон и начинается самое интересное.</p>
<ol>
<li><p>Не работает вообще ничего. Телефон может только звонить и отправлять сообщения. Специальная программа учит тебя пользоваться жестовым интерфейсом (который со времён n9 как-то стал одновременно и удобнее и перегруженнее). Из многочисленной периферии работает только камера, wifi и gsm-модуль. Можно посмотреть чужие фотографии. Интернет настоятельно рекомендует обновиться. Окей, обновляемся.</p></li>
<li><p>Не работает регистрация в сервисах Jolla (которая по старой доброй традиции пришедшей ещё из Nokia необходима чтобы получать обновления). Получив от меня все необходимые данные и соединившись с глобальной сетью через wifi телефон сообщает что что-то пошло не так. После беглого поиска в интернете узнаю, что у меня уже есть регистрационная запись в сервисе Jolla и создавать вторую привязанною к тому же почтовому адресу нельзя, а сказать мне это более доступным способом телефон не умеет. Окей, заходим на сайт Jolla, через веб-интерфейс сбрасываем пароль, меняем его вводим его на телефоне, обновляемся.</p></li>
<li><p>Не работает LTE. Тупо не активен нужный пункт меню. Читаем интернет. Это не помогает. Сбрасываем телефон к чёртовой бабушки до заводских настроек. После первого пакета обновлений обнаруживаем нужный пункт меню активным и на всякий случай вбиваем туда параметры APN своего сотового оператора. Обновляемся окончательно, всё работает.</p></li>
<li><p>Не работает подключение телефона к компьютеру как usb-storage поскольку корень с /home’ом сидит на btrfs. Надо заметить, что стек технологий там вообще интересный: корень на btrfs, инит-система — systemd, а графика на waylend. Зато можно выгрузить фотографии digiKam’ом как с камеры или подключить по mtp как плеер. Последнее у меня не получилось из-за KDE-проблем и я решил просто монтировать устройство по сети через sshfs.</p></li>
<li><p>Не работает ssh. Прочитал инструкцию и форум — не помогает. Путём тыканья эмулятора терминала на самом телефоне (он кстати шикарный, хотя и не без недостатков) я обнаружил что для sshd не сгенерирована пара ключей. Потому он и не стартует. Сгенерировал их руками в той же консоли и всё заработало.</p></li>
<li><p>Не работает NFC. Ну то есть работает (в частности через NFC-модуль телефон читает RFID-метку на цветной крышке), но интерфейса для управления NFC-модуля пока нет и никакой возможности узнать что оный модуль вообще есть на борту не влезая в консоль или документацию тоже нет.</p></li>
</ol>
<p>Продолжение следует…</p>
<p>Тех кому кажется что у меня слишком много спойлеров могу успокоить: Jolla позаботилась о своих пользователях и выдала каждому уникальный набор багов требующий своего особого напильника. Во всяком случае именно это ощущение возникает при чтении их форума-стекэксчендж-багзиллы.</p>
<p>Возможно у вас возник закономерный вопрос: если всё так плохо, то что же чёрт подери я приобретаю за кровные 350€ кроме политического волеизъявления? Где же тут луч света в тёмном царстве? Их есть у нас.</p>
<ul>
<li><p>Во-первых это просто красиво. Нет. Это охренительно красиво. Видимо это как-то связано с qml’ем и возможностью переверстать каждый элемент интерфейса упоротым дизайнером, но описывать это совершенно бессмысленно. Даже если вы не сможете пользоваться данным устройством, вы всегда можете подарить его своей женщине, которая будет использовать его как очень красивый лаунчер андроид-приложения и джаббер-клиент (который там искоропки) для общения с вами.</p></li>
<li><p>Во-вторых это общение. Что может быть прекраснее обсуждения на специальном стекэксчендж форуме (который там вместо багзиллы) возникших в процессе использования проблем с другими пользователями и разработчиками? Пользователи рассказывают как обходить проблемы, разработчики обещают починить баги или приделать фичу, пользователи не только находят баги, но временами даже чинят их, разработчики жалуются на перспективу остаться без блоба от snapdragon года через полтора. Идиллия.</p></li>
<li><p>В-третьих это эргономика. Если не вдаваться в подробности, то основная идея интерфейса Jolla это замена тыканья в виджет пальцем на сдвиг экрана в произвольном месте в нужную сторону, что требует гораздо меньше ловкости, а также бессмысленного перемещения пальца над экраном. Основная задача — осуществлять все основные манипуляции с телефоном одним, вероятнее всего большим пальцем, вероятнее всего левой руки, вероятнее всего на бегу. В целом это даже получается. Хотя при этом очень забавно, что для этих целей устройство слишком велико и не умеет Swype.</p></li>
<li><p>В-четвёртых это ожидание чуда. Сам процесс превращения кирпича в твоих руках в более-менее работоспособное устройство стоит любых денег.</p></li>
</ul>
<p>Теперь серьёзно.</p>
<ul>
<li><p>Если вы фанатичный политически активный линуксоид купите себе устройство чтобы поддержать финский стартап «пошедший против системы». В худшем случае подарите своей женщине.</p></li>
<li><p>Если вы эталонный хипстер купите себе устройство потому что оно выглядит довольно стильно и встречается примерно на два-три порядка реже чем iPhone (это Sailfish OS, но вы наверное даже не слышали о том что это такое).</p></li>
<li><p>Если вы красноглазый гик и вам очень нужно менять порядок монтирования файловых систем при загрузке вашего телефона или возможность подцепить к нему по i2c какой-то свой контроллер купите себе устройство потому как за вычетом дизайнеров разработчики устройства примерно такие же люди. Все вышеперечисленные проблемы вас никак не коснуться.</p></li>
<li><p>Если вы чувствуете себя линуксоидом, но у вас нет лишних 350€ чтобы отдать их в фонд помощи замерзающих финов портируйте Sailfish OS на Nexus, n9 или то устройство которое у вас есть под рукой. Почему бы и нет.</p></li>
</ul>
<p>Во всех остальных случаях просто купите себе андроид, поскольку на данный момент устройство является красивым андроид лаунчером. Это правда никак не относится к вашему покорному слуге, который получил от устройства всё то чего ему так давно не хватало: возможность осуществлять звонки не выходя на крышу, задавать множество таймеров на различные задачи и поставить Five to One на будильник.</p>]]></summary>
</entry>
<entry>
    <title>Немного о лунном.</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-06-18-about-lua.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-06-18-about-lua.html</id>
    <published>2014-06-18T00:00:00Z</published>
    <updated>2014-06-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Лунный примечателен тем что это очень простой язык. Несмотря на такие языковые возможности как анонимные функции и замыкания это очень традиционный процедурный язык. Языковые конструкции в нём означают примерно то чего от них и ждёшь. Его простота столь велика что определённым образом провоцирует беспечность программиста. В следствие этой беспечности столкновения со специфичными для языка вещами обычно бывают особенно болезненны и полны детской обиды. Здесь перечислено несколько элементарных моментов, столкновение с которыми у программиста не на лунном может вызвать недоумение и предварительное ознакомление с которыми должно упростить вхождение в язык тем кто так и не прочёл документацию<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<ol>
<li><p>Массивы индексируются начиная с единицы<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">v <span class="ot">=</span> <span class="ot">{</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">,</span> <span class="dv">3</span> <span class="ot">}</span>

<span class="kw">for</span> i <span class="ot">=</span> <span class="dv">0</span><span class="ot">,</span> <span class="ot">#</span>v <span class="kw">do</span>
    <span class="fu">print</span><span class="ot">(</span> v<span class="ot">[</span>i<span class="ot">]</span> <span class="ot">)</span>
<span class="kw">end</span>

<span class="co">-- nil</span>
<span class="co">-- 0</span>
<span class="co">-- 1</span>
<span class="co">-- 2</span>
<span class="co">-- 3</span></code></pre></div></li>
<li><p>Все переменные глобальные, если не указано что они локальные<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">x <span class="ot">=</span> <span class="dv">1</span>
y <span class="ot">=</span> <span class="dv">13</span>

z <span class="ot">=</span> <span class="kw">function</span><span class="ot">()</span>
    x <span class="ot">=</span> <span class="dv">0</span>
    <span class="kw">local</span> y <span class="ot">=</span> <span class="dv">0</span>
<span class="kw">end</span>

<span class="fu">print</span><span class="ot">(</span> x<span class="ot">,</span> y <span class="ot">)</span>
z<span class="ot">()</span>
<span class="fu">print</span><span class="ot">(</span> x<span class="ot">,</span> y <span class="ot">)</span>

<span class="co">-- 1    13</span>
<span class="co">-- 0    13</span></code></pre></div></li>
<li><p>Захват переменных в область видимости (в том числе и в замыкания) осуществляется по ссылке или по имени<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. Таким образом можно невозбранно модифицировать переменные из замыкания в которое они захвачены. Но при передаче значения в функцию в качестве аргумента создаётся новая <strong>локальная</strong> ссылка и изменения переменной во внешней области видимости происходить не будет<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">x <span class="ot">=</span> <span class="dv">1</span>
y <span class="ot">=</span> <span class="dv">13</span>

z <span class="ot">=</span> <span class="kw">function</span><span class="ot">(</span> v <span class="ot">)</span>
    v <span class="ot">=</span> <span class="dv">0</span>
    y <span class="ot">=</span> <span class="dv">0</span>
<span class="kw">end</span>

<span class="fu">print</span><span class="ot">(</span> x<span class="ot">,</span> y <span class="ot">)</span>
z<span class="ot">(</span> x <span class="ot">)</span>
<span class="fu">print</span><span class="ot">(</span> x<span class="ot">,</span> y <span class="ot">)</span>

<span class="co">-- 1    13</span>
<span class="co">-- 1    0</span></code></pre></div></li>
<li><p>Если инициализировать локальную переменную анонимной функцией, то она не будет доступна внутри области видимости анонимной функции. Таким образом мы вполне можем вызывать такую функцию рекурсивно<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">f <span class="ot">=</span> <span class="kw">function</span><span class="ot">(</span> x <span class="ot">)</span>
    f<span class="ot">(</span> x <span class="ot">)</span>
<span class="kw">end</span>

<span class="co">-- Всё в порядке. Путь к переполнению стека открыт.</span>

<span class="kw">local</span> f1 <span class="ot">=</span> <span class="kw">function</span><span class="ot">(</span> x <span class="ot">)</span>
    f1<span class="ot">(</span> x <span class="ot">)</span>
<span class="kw">end</span>

<span class="co">-- Всё плохо.</span>

<span class="kw">local</span> f2
f2 <span class="ot">=</span> <span class="kw">function</span><span class="ot">(</span> x <span class="ot">)</span>
    f2<span class="ot">(</span> x <span class="ot">)</span>
<span class="kw">end</span>

<span class="co">-- А вот так, как не странно, всё хорошо.</span></code></pre></div></li>
<li><p>В lua свои собственные особенные регулярные выражения<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>.</p>
<ul>
<li>Эскейпинг магических символов осуществляется при помощи ‘%’.</li>
<li>Символы пунктуации нуждаются в эскейпинге.</li>
<li>‘-’ это такой ленивый ‘*’.</li>
<li>Ну и расширений по мелочи.</li>
</ul></li>
<li><p>Знак неравенства. Поскольку все современные промышленные языки программирования так или иначе произошли от C (Java и C#, например), у программиста нет сомнений относительно того как должен выглядеть оператор неравенства — <strong>!=</strong>. А между тем из числа арифметических операторов и условных операторов форма этого оператора пожалуй наиболее непостоянна: <strong>/=</strong> в Haskell, <strong>&lt;&gt;</strong> в Pascal и PHP. лунном неравенство это неожиданно <strong>~=</strong><a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="fu">print</span><span class="ot">(</span> <span class="dv">1</span> <span class="er">!=</span> <span class="dv">2</span> <span class="ot">)</span>

<span class="co">-- Ошибка компиляции</span>

<span class="fu">print</span><span class="ot">(</span> <span class="dv">1</span> <span class="ot">~=</span> <span class="dv">2</span> <span class="ot">)</span>

<span class="co">-- А вот так просто true</span></code></pre></div></li>
<li><p>Форматированный вывод чисел. Поскольку в лунном языке нет целых чисел и вместо них используют числа с плавающей запятой двойной точности, то переполнение величины в 2<sup>51</sup> приводит к потере точности целой части. Однако при преобразование числа в строку, переход от целочисленной к экспоненциальной записи происходит раньше этого предела. Этот переход ошибочно воспринимается некоторыми как потеря точности в целой части, хотя это не так и чинится настройками форматирования.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua"><span class="fu">print</span><span class="ot">(</span> <span class="dv">2</span> <span class="ot">^</span> <span class="dv">51</span> <span class="ot">)</span>

<span class="co">-- 2.2517998136852e+15</span>

<span class="fu">print</span><span class="ot">(</span> <span class="fu">string.format</span><span class="ot">(</span> <span class="st">&quot;%.0f&quot;</span><span class="ot">,</span> <span class="dv">2</span> <span class="ot">^</span> <span class="dv">51</span> <span class="ot">)</span> <span class="ot">)</span>

<span class="co">-- 225179981368528</span></code></pre></div></li>
<li><p>Nil не может быть последним элементом массива. Если последним элементом массива оказывается nil, массив укорачивается на этот элемент.</p>
<div class="sourceCode"><pre class="sourceCode lua"><code class="sourceCode lua">list <span class="ot">=</span> <span class="ot">{</span> <span class="dv">1</span><span class="ot">,</span> <span class="dv">2</span><span class="ot">,</span> <span class="dv">3</span> <span class="ot">}</span>

list<span class="ot">[</span><span class="dv">2</span><span class="ot">]</span> <span class="ot">=</span> <span class="kw">nil</span>

<span class="fu">print</span><span class="ot">(</span> table<span class="ot">.</span>unpack<span class="ot">(</span> list <span class="ot">)</span> <span class="ot">)</span>

<span class="co">-- 1    nil    3</span>

list<span class="ot">[</span><span class="dv">3</span><span class="ot">]</span> <span class="ot">=</span> <span class="kw">nil</span>

<span class="fu">print</span><span class="ot">(</span> table<span class="ot">.</span>unpack<span class="ot">(</span> list <span class="ot">)</span> <span class="ot">)</span>

<span class="co">-- 1</span>

<span class="fu">print</span><span class="ot">(</span> <span class="ot">#{</span> <span class="kw">nil</span><span class="ot">,</span> <span class="kw">nil</span><span class="ot">,</span> <span class="kw">nil</span> <span class="ot">}</span> <span class="ot">)</span>

<span class="co">-- 0</span></code></pre></div></li>
</ol>
<p>Также если вы кондовый сишник, вам безусловно очень понравятся begin и end, но это уже совсем другая история.</p>
<p>P.S: Запись основана на реальных событиях. Каждым из пунктов прострелил себе колено я или кто-то из моих знакомых.</p>
<p>P.P.S: Продолжение следует.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Важно понимать, что никакой тайны из этих вещей не делается. Наоборот, все эти вещи описаны в официальной документации к языку. Она у него кстати довольно короткая. Просто все её читают в лучшем случае по диагонали.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#2.1">здесь</a> где-то начиная с «We use the term sequence…».<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#3.2">здесь</a> начиная с «…Any variable name…».<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Все глобальные переменные связываются по имени. Если точнее то все глобальные переменные просто элементы хэштаблицы _ENV и связывание с ними это поиск значения в этой таблице по имени. Факт этот настолько поразил меня, что не упомянуть о нём совсем я не мог, хотя он и выходит за рамки обсуждения.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#3.2">здесь</a> начиная с «…function’s formal parameter…».<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#3.4.10">здесь</a> начиная с «…The statement local…».<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#6.4.1">здесь</a> всё.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Читать <a href="http://www.lua.org/manual/5.2/manual.html#3.4.3">здесь</a> начиная с «…The operator ~=…».<a href="#fnref8">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Почему хаскель не подходит для скриптования?</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-06-13-why-haskell-bad-for-scripting.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-06-13-why-haskell-bad-for-scripting.html</id>
    <published>2014-06-13T00:00:00Z</published>
    <updated>2014-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Прежде чем обсуждать недостатки такого безусловно примечательного инструмента следует определиться с таким самоочевидным понятием как скриптование. Речь пойдёт в первую очередь о так называемых скриптах пользователя: небольших программах обеспечивающих интерфейс взаимодействия пользователя и более сложной системы. Например скрипты emacs’а, vim’а или даже acpid’а. В определённой степени можно говорить и командной оболочке операционной системы в принципе с некоторыми оговорками. Следует различать пользовательские скрипты и приложения для одного запуска: последние могут сколь угодно сложны, громоздки, запутаны, не очевидны и нечитабельны, поскольку читать их никто не будет и пишутся они обычно на одном дыхание, а со своими скриптами вам скорее всего ещё долгое время жить. Итак пользовательский скрипт это программа:</p>
<ul>
<li>предоставляющая интерфейс к более сложной системе чем система самого скрипта (в противном случае было бы проще поправить код системы)<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>;</li>
<li>небольшая (в противном случае кто кого скриптует и кто куда встроен<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>);</li>
<li>понятная (поскольку никто даже комментариев не пишет, не говоря уж про документацию);</li>
<li>как правило не критичная по производительности.</li>
</ul>
<p>Для таких задач традиционно используются shell, lua, js, scheme и прочие языки поразительно схожие с этими синтаксисом и семантикой (хотя некоторые умудряются для этого сравнительно успешно использовать целый python). Что объединяет эти языки? Слабая (у всех кроме scheme) динамическая типизация и позднее связывание. Оно и понятно, считается что если убрать из программы аннотацию типов то она станет выглядеть проще. Однако на сдачу мы получаем невозможность проверить хотя бы наличие вызываемых функций и существование используемых переменных не говоря уж о разумности применения одного к другому. Поскольку покрывать тестами подобного рода код будут немного позже того как к нему напишут документацию, то ситуация выглядит так себе.</p>
<p>При этом следует понимать, что статическая типизация и ранее связывание вообще говоря совсем не требуют аннотации типов. Компилятор зачастую может понять какой тип имеет то или иное выражение просто из контекста используемых функций. Компилятор может осуществлять вывод типов даже в таком языке как C++, где система типов вообще один из кругов Ада. Для более простого языка это осуществить ещё проще. Всё что ему нужно это твёрдая уверенность, что в середине выполнения программы не появятся новые функции, а семантика существующих типов не изменится. Довольно забавно, но для очерченных нами задач это практически всегда верно поскольку для решения простых задач такие динамические возможности едва ли понадобятся, а сложные мы вроде бы решать и не собирались<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p>Теперь посмотрим в свете наших задач на Haskell. Итак Haskell это ленивый, функциональный язык программирования с полиморфизмом на классах типов:</p>
<ul>
<li>вывод типов вместо динамической типизации: прекрасно работает;</li>
<li>функции высшего порядка вместо метапрограммирования: с учётом возможности определять операторы и тем что у основных конкурентов нет разделения на время компиляции и время исполнения, ок;</li>
<li>полиморфизм всего и вся вместо динамической диспетчеризации: вполне хватает;</li>
</ul>
<p>Плюс сопоставление с образцом, которое у конкурентов как правило отсутствует (ну кроме scheme и прочих лиспов). Что не так? А не так примерно следующее:</p>
<ul>
<li><p>Плохая стандартная библиотека. Многие вещи сделаны плохо поскольку пришли к нам из тех времён когда функциональные языки не умели готовить. Многие вещи сделаны плохо поскольку сделано с учётом особенностей реализации ghc. Так например несмотря на полиморфизм, большая часть функций Prelude мономорфна по используемому контейнеру. Или по используемому числовому типу. В той же стандартной библиотеке есть полиморфные функции, но они запрятаны в другие модули и часто создают конфликт имён, разрешение которого портит всю радость. Ну и за Monad который не Functor отдельное спасибо.</p></li>
<li><p>Сложная стандартная библиотека. В Prelude есть целых два типа для для обозначения целого знакового числа: Int (для числа размером в машинное слово) и Integer (для целого числа бесконечной точности). В Data.Int можно найти целые числа другого размера, а в Data.Word беззнаковые целые числа. Такое разнообразие типов безусловно не доведёт до добра скриптописателя. Он может <del>испугаться</del>начать решать проблемы производительности и не допишет свой скрипт никогда, поскольку будет писать стандартные функции для работы с Word8, отсутствующие в стандартной библиотеке. Для сравнение Lua использует только один тип — Number, который представляет собой закоробкованное число с плавающей запятой двойной точности (то есть Double).</p></li>
<li><p>Стандарт языка. Haskell2010 довольно простой язык у которого есть всё чтобы писать на нём программы. Однако программы эти будут содержать чёртову уйму бойлерплейта, интересных структур данных и коллизий пространств имён. Можно воспользоваться расширениями GHC. Код безусловно станет лаконичнее и яснее, но возникнут другие проблемы: выбор языковых средств (самый банальный пример это функциональные зависимости vs семейства типов), неоднозначности приводящие к трудности проверки типов, усложнение системы типов настолько что язык становится понятным вообще только компилятору. А ещё расширений так много что весь GHC-haskell не знает никто. Вместе с этим, стандартная библиотек старается по возможности избегать языковых расширений, что делает её именно такой как было описано в начале.</p></li>
<li><p>Реализация. Мне на сегодняшний день доводилось иметь дело с тремя реализациями haskell.</p>
<ul>
<li><p>GHC. Мы говорим haskell подразумеваем GHC. Мы говорим о стандартной библиотеке haskell подразумеваем base, а вовсе не haskell2010. Если вы хотите использовать существующие библиотеки то вам придётся использовать GHC. Впрочем это очень хороший компилятор с очень мощной и гибко настраиваемой рантайм-системой: в то время как кто-то всё ещё считает ссылки и никак не выпилит GIL, рантайм-система GHC вертит тысячами тредов и дефрагментирует кучу. Однако у этого всего есть оборотная сторона. GHC громоздок, как в сборке так и в виде библиотеки, а его рантайм избыточен и на небольших приложениях выглядит как лазерная атака из космоса для того чтобы поджарить тосты. Несмотря на все ухищрения и тюнинг рантайма ваше приложение вряд ли будет использовать меньше мегабайта под кучу. Не исключено, что больше тоже вряд ли, но тем не менее.</p></li>
<li><p>Jhc/Ajhc. Компилятор haskell в C. Если GHC придерживается традиционной модели компиляции, где есть раздельная компиляция различных единиц трансляции, а затем линковка, то Jhc проводит анализ, трансформации и компиляцию всего кода проекта. Полученный код на C отчаянно пытается управлять памятью при помощи выведенных регионов, но не справляется и всё в итоге опять скатывается в сканирующую сборку мусора. Эта реализация намного проще и компактнее, но по своей природе больше стремиться быть хаскелем для микроконтроллеров. Язык который она поддерживает — Haskell98 и несколько GHC-шных расширений того времени. Для нашей задачи она бесполезна.</p></li>
<li><p>Haste. Компилятор haskell в JS. Несмотря на жутковатый мапинг данных хаскеля в данные JS и время от времени возникающие проблемы с продолжениями, эта реализация ближе всего к нашим задачам. Haste использует фронтенд ghc и работает уже непосредственно с stg-кодом. Это решает проблему расширений, поскольку почти все они реализованы на уровне фронтенда. И всё же это 40 мегабайт компилятора и 13 — nodejs. Многовато. Кроме того v8 жрёт памяти как не в себя и встраивается только инженерами гугла.</p></li>
</ul></li>
<li><p>Слишком много приведений типов. Вот код на хаскеле:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  avrg xs <span class="fu">=</span> sum xs <span class="fu">/</span> length xs</code></pre></div>
<p>Среднее по списку значение это сумма всех значений в списке разделённая на длину списка. Всё хорошо? Нет. Оператор (/) не определён для целочисленного типа. Длинна списка это значение типа Int. Но даже если она будет Integer или сферический целочисленный тип в вакууме (Integral) ничего не изменится: делитель, делимое и результат должны быть одного типа, а в данном случае нас интересует именно нецелочисленный результат<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. Нужно писать как-то так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  avrg xs <span class="fu">=</span> sum xs <span class="fu">/</span> fromIntegral (length xs)</code></pre></div>
<p>В lua нет такой проблемы поскольку как уже писалось выше там всего один тип для записи чисел вообще. Однако в C (от которого в известной степени хаскель унаследовал примитивные типы) такой проблемы тоже нет: компилятор просто неявно приводит целое число к какой-нибудь плавучке.</p></li>
</ul>
<p>Пущей объективности ради следует заметить, что языки из круга конкурентов совсем не обязательно лишены подобных недостатков. И тем не менее будем считать что всё дело именно в них. Если всё перечисленное плохо и не нужно, то что нужно?</p>
<ul>
<li><p>Компилятор некого семантического надмножества Haskell2010. Стандарт довольно ядра языка довольно лаконичен. Возможно можно было бы исключить из него newtype поскольку он опять же заставляет задумываться, а в нашем случае это плохо. Из расширений стоит оставить:</p>
<ul>
<li><p>Многопараметрические классы типов и функциональные зависимости. Концептуальным решением было бы даже ограничиться классами где все параметры кроме одного зависимы<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p></li>
<li><p>Перегрузка оставшихся немногочисленных литералов. В стандарте перегружены числовые литералы и do-нотация. Соответственно остаётся перегрузить строковые (есть в ghc) и списки (есть в ghc).</p></li>
<li><p>GADT’ы. Упрощают описание древовидных структур и гетерогенных коллекций.</p></li>
<li><p>Data/Generic и прочее обобщённое программирование. В плане унылости мало что может потягаться с case’ом по двенадцати конструкторам, одиннадцать веток которого не делают ничего.</p></li>
<li><p>Управляемое неявное приведение типов.</p></li>
</ul></li>
<li><p>Компиляция неразделяемого кода. Шаблонный полиморфизм как в C++ и jhc. Тотальный инлайнинг и трансформация всего кода программы (интересно, насколько это реально в условиях just it time компиляции).</p></li>
<li><p>Кодогенератор в некую простую существующую переносимую виртуальную машину или даже язык. Предпочтительнее система со сканирующей сборкой мусора (что-то кондовое вроде mark &amp; sweep) и без jit-компилятора. Писать свою динамическую среду исполнения не стоит. Их уже итак больше чем нужно.</p></li>
<li><p>Простая стандартная библиотека.</p>
<ul>
<li><p>Было бы забавно обозвать монаду аппликативным функтором, но не понятно насколько это будет корректно.</p></li>
<li><p>Foldable и Traversable сделать классами от двух переменных где тип содержимого зависит от типа контейнера.</p></li>
<li><p>Не хранить строки в виде списка чаров. Это вызывает слишком много волнения и других строк. По большому счёту строка это массив кодпоинтов, но непонятно как тогда осуществлять паттерн-матчинг.</p></li>
<li><p>Стандартизованный механизм и формат исключений (вот уже GADT и в стандартной библиотеке).</p></li>
<li><p>Стандартные монадные трансформеры? Почему бы и нет. Плюс монада для логического вывода с бэктрекингом.</p></li>
<li><p>Регулярные выражения и комбинаторы парсеров. Последнее вообще киллер-фича функциональшины и ML-подобных.</p></li>
<li><p>Стандартные контейнеры типа Map, Set и так далее.</p></li>
<li><p>Парсеры для работы c json, xml, yaml.</p></li>
</ul></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Ну или у вас просто нет возможности поправить код системы. Но тогда горе побеждённым! Какой смысл обсуждать достоинства и недостатки brainfuck, если это единственный доступный вам способ изменить поведение вашей системы?<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Угу. Например в код emacs на elisp встроено небольшое ядро на C.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Существует спорное утверждение, что динамика очень нужна для создание EDSL’ей которые действительно позволяют повысить простоту кода и довольно эффективно съесть сложность и громоздкость кода.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Иначе у нас бы использовалось целочисленное деление.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Да-да. Это семейства типов. Но они выглядят более громоздкими. Функциональные зависимости более лаконичны что-ли.<a href="#fnref5">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>e</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-05-24-e.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-05-24-e.html</id>
    <published>2014-05-24T00:00:00Z</published>
    <updated>2014-05-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Четыре года назад, я радовался работе с бесконечными списками и вычислял e суммируя ряд Тейлора так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> map (\x <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">/</span> fac x) [<span class="dv">0</span><span class="fu">..</span>]
    <span class="kw">where</span>
        fac n <span class="fu">=</span> foldl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>n]
        sum (x<span class="fu">:</span>xs) <span class="fu">=</span> sumtr (x<span class="fu">:</span>xs) <span class="dv">0</span>
        sumtr (x<span class="fu">:</span>xs) acc
            <span class="fu">|</span> (acc <span class="fu">==</span> acc <span class="fu">+</span> x) <span class="fu">=</span> acc
            <span class="fu">|</span> otherwise <span class="fu">=</span> sumtr xs (x <span class="fu">+</span> acc)</code></pre></div>
<p>Случайно найдя предыдущий сниппет и смахнув слезу умиления, я переписал суммирование уже со знанием стандартной библиотеки.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> takeWhile (<span class="fu">/=</span><span class="dv">0</span>) <span class="fu">$</span> map (\v <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">/</span> product [<span class="dv">1</span><span class="fu">..</span>v]) [<span class="dv">0</span><span class="fu">..</span>]</code></pre></div>
<p>Проблема в том, что этот вариант аллоцировал в 10 раз больше памяти чем первый. Стало как-то неудобно и я заменил вычисление факториала для каждого нового члена ряда Тейлора на вычисление непрерывного списка факториалов, где каждый следующий элемент умножение номера члена ряда на значение предыдущего элемента.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> takeWhile (<span class="fu">/=</span><span class="dv">0</span>) <span class="fu">$</span> map (<span class="dv">1</span><span class="fu">/</span>) <span class="fu">$</span> scanl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>]</code></pre></div>
<p>Количество аллоцированной памяти вышло на уровень первого варианта. Однако в первом варианте у нас используется наивный факториал и он всё равно работает замечательно. Разница состоит в том, что первый вариант суммирует ряд до тех пор пока сумма изменяется, а третий — до тех пор пока n-ый член ряда не станет нулём. Любому кто знаком с числами с плавающей запятой понятно что первое условие выполнится быстрее второго. Попробуем использовать именно первое условие. Для этого из бесконечного списка факториалов получим бесконечный список сумм, выделим пары текущая сумма/следующая сумма и будем разматывать список до тех пор пока суммы не равны. Последняя сумма и есть наша.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> fst <span class="fu">$</span> last <span class="fu">$</span> takeWhile (uncurry (<span class="fu">/=</span>)) <span class="fu">$</span> (\v <span class="ot">-&gt;</span> zip v (tail v)) <span class="fu">$</span> scanl1 (\v0 v1 <span class="ot">-&gt;</span> v0 <span class="fu">+</span> <span class="dv">1</span> <span class="fu">/</span> v1) <span class="fu">$</span> scanl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>]</code></pre></div>
<p>Мы наконец заметно превзошли по выделенной памяти первый вариант. Но не в 10 раз, а в полтора и ценой дополнительного времени на сборку мусора. Это скажем так себе результат.</p>
<p>P.S: Продолжение следует.</p>]]></summary>
</entry>

</feed>
