<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>All your need is love and a little bit of LSD — tagged haskell</title>
    <link href="https://ndtimofeev.github.io/ru/tags/haskell.xml" rel="self" />
    <link href="https://ndtimofeev.github.io" />
    <id>https://ndtimofeev.github.io/ru/tags/haskell.xml</id>
    <author>
        <name>Nikita Timofeev</name>
        <email>ndtimofeev@gmail.com</email>
    </author>
    <updated>2016-01-26T00:00:00Z</updated>
    <entry>
    <title>Моему другу Серёже Алирзаеву посвящается…</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2016-01-26-l29ah.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2016-01-26-l29ah.html</id>
    <published>2016-01-26T00:00:00Z</published>
    <updated>2016-01-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Понапридумывали расширений!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE DeriveTraversable #-}</span>

<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Foldable</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Proxy</span>

<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Peano</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Peano</span>
<span class="fu">&gt;</span>     <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">FixedList</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) a <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">FixedList</span> <span class="dt">Z</span> a
<span class="fu">&gt;</span><span class="ot">     (:.) ::</span> a <span class="ot">-&gt;</span> <span class="dt">FixedList</span> n a <span class="ot">-&gt;</span> <span class="dt">FixedList</span> (<span class="dt">S</span> n) a

<span class="fu">&gt;</span> <span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:.</span>

<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">FixedList</span> n a)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">FixedList</span> n a)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">FixedList</span> n)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Foldable</span> (<span class="dt">FixedList</span> n)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Traversable</span> (<span class="dt">FixedList</span> n)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nill</span>)
<span class="co">-- (2 :. 3 :. 4 :. Nill)</span>

λ<span class="fu">&gt;</span> find (<span class="fu">==</span><span class="dv">2</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nill</span>)
<span class="co">-- Just 2</span>

λ<span class="fu">&gt;</span> mapM_ print (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nill</span>)
<span class="co">-- 1</span>
<span class="co">-- 2</span>
<span class="co">-- 3</span></code></pre></div>
<p>Вроде норм.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sumOurSpecialFixedList ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span>
     <span class="dt">FixedList</span>
       (<span class="ch">&#39;S</span>
          (<span class="ch">&#39;S</span>
             (<span class="ch">&#39;S</span>
                (<span class="ch">&#39;S</span>
                   (<span class="ch">&#39;S</span>
                      (<span class="ch">&#39;S</span>
                         (<span class="ch">&#39;S</span>
                            (<span class="ch">&#39;S</span>
                               (<span class="ch">&#39;S</span>
                                  (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S &#39;</span><span class="dt">Z</span>))))))))))))))))))))
       a
     <span class="ot">-&gt;</span> a
sumOurSpecialFixedList <span class="fu">=</span> sum</code></pre></div>
<p>Чо?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">type</span> family <span class="dt">N2P</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="dt">N2P</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Z</span>
<span class="fu">&gt;</span>     <span class="dt">N2P</span> n <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">N2P</span> (n <span class="fu">-</span> <span class="dv">1</span>))

<span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">FList</span> n <span class="fu">=</span> <span class="dt">FixedList</span> (<span class="dt">N2P</span> n)</code></pre></div>
<p>Чо?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sumOurSpecialFixedList ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">FList</span> <span class="dv">20</span> a <span class="ot">-&gt;</span> a
sumOurSpecialFixedList <span class="fu">=</span> sum</code></pre></div>
<p>Ок.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>) <span class="fu">!!</span> <span class="dv">1</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>
    <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> ‘[a]’
                with actual <span class="kw">type</span> ‘<span class="dt">FixedList</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S &#39;</span><span class="dt">Z</span>))) <span class="dt">Integer</span>’
    <span class="dt">Relevant</span> bindings include<span class="ot"> it ::</span> a (bound at <span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">1</span>)
    <span class="dt">In</span> the first argument <span class="kw">of</span> ‘(<span class="fu">!!</span>)’, namely ‘(<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>)’
    <span class="dt">In</span> the expression<span class="fu">:</span> (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>) <span class="fu">!!</span> <span class="dv">1</span>
    <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>) <span class="fu">!!</span> <span class="dv">1</span></code></pre></div>
<p>Ле!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">type</span> family <span class="dt">P2N</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="dt">P2N</span> <span class="dt">Z</span>     <span class="fu">=</span> <span class="dv">0</span>
<span class="fu">&gt;</span>     <span class="dt">P2N</span> (<span class="dt">S</span> n) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dt">P2N</span> n

<span class="fu">&gt;</span><span class="ot"> findex ::</span> (<span class="dt">KnownNat</span> n, n <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&lt;=</span> <span class="dt">P2N</span> m) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">FixedList</span> m a <span class="ot">-&gt;</span> a
<span class="fu">&gt;</span> findex proxy xs <span class="fu">=</span> toList xs <span class="fu">!!</span> fromInteger (natVal proxy)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XDataKinds</span>
λ<span class="fu">&gt;</span> findex  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">2</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>)
<span class="co">-- 3</span>
λ<span class="fu">&gt;</span> findex  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">0</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>)
<span class="co">-- 1</span></code></pre></div>
<p>Пук. Пёрд. Среньк. Ко-ко-ко-зависимые-типы.</p>]]></summary>
</entry>
<entry>
    <title>О MskHUG в декабре 2015го года…</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-12-11-meetup.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-12-11-meetup.html</id>
    <published>2015-12-11T00:00:00Z</published>
    <updated>2015-12-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Сходил на слёт хаскелистов в Яндексе, послушал доклады. Коротко:</p>
<ul>
<li><p>Лучший доклад был пожалуй про Servant. Человек настолько задороно выступил, что мне захотелось оный Servant потыкать, хотя у меня и нет задач для которых мог бы понадобится веб-сервер. Чуваку, который сравнивал сложность комбинирования роутов веб-сервера и сложность комбинирования парсеров в parsec посылаю луч ненависти: во втором случае сложность вылезает из-за типично нетревиальных грамматик и того что парсек говно и не умеет в бэктрекинг (но это совсем другая история).</p></li>
<li><p>Наиболее полезным для меня оказался доклад про зависимые типы, который оказался не про зависимые типы, а про костыли в GHC, которые позволяют типизировать типы типами. Собственно я наконец примерно понял как работает этот механизм. А вот квантор <code>pi</code> мне напомнил С++14 с его <code>decltype(auto)</code>.</p></li>
<li><p>Зефиров опять рассказывал что-то очень интересное и я опять мало что смог вынести из доклада: во-первых опоздал к началу, во-вторых сам доклад проводился в экстремальных условиях и в-третьих Зефиров довольно хреновый докладчик.</p></li>
<li><p>Крайне полезным был доклад <span class="citation">@qnikst</span>’а. Жаль что он не успел его дочитать. Всё бы ничего, но мне как-то стабильно не нужно вызывать внешние функции из haskell руками. Обычно дело ограничивается сериализацией/десериализацией сишных структур прилетевших из ядерных интерфейсов. Хотя идея хакнуть рантайм через unsafe ffi-вызовы, которые блокируют тред и gc мне показалась очень интересной, хотя и вредной.</p></li>
<li><p>Посмотрел на живого <del>Ленина</del><span class="citation">@qnikst</span>’а. Он классный <del>,от него сияние исходит</del>.</p></li>
<li><p>Попытался объяснить живому <span class="citation">@segfault</span>’у радость комбинатора неподвижной точки.</p></li>
<li><p>Попытался объяснить живому <span class="citation">@segfault</span>’у радость GREEN’а, полнопрограмной компиляции и отказа от стека в пользу распихивания аргументов функций по фиксированным непересекающимся регистрам.</p></li>
</ul>
<p>Больше не сделал ничего ползного. В следующий раз нужно будет запастись:</p>
<ul>
<li><p>Бейджем с ником на жуйке.</p></li>
<li><p>Карточками с вопросами, чтобы передавать их по кругу по столу во время неформальной части.</p></li>
<li><p>Докладом про Remote Monad, если к этому времени мой <code>Action</code> будет честным частным случаем.</p></li>
</ul>]]></summary>
</entry>
<entry>
    <title>О скоупах</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-08-02-scope.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-08-02-scope.html</id>
    <published>2015-08-02T00:00:00Z</published>
    <updated>2015-08-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>А вот ещё одна хитрая задачка. Положим у нас есть несколько устройств, которые мы можем как-то дёргать через <code>DevHnd a</code> (где <code>a</code> — тип-параметр характеризующий устройство). Проблема в том, что если два треда будут рулить устройством одновременно, то результат будет трудно предсказать. Хорошо, вводим концепцию владения устройством: управлять устройством<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> можно только завладев им, если кто-то другой завладел устройством до тебя, то ты ждёшь пока устройство освободится. Просто, но есть пара нюансов:</p>
<ul>
<li>мы говорим «блокировка» и подразумеваем «дедлок», поскольку в реальной жизни тред должен контролировать состояние более одного устройства одновременно;</li>
<li>из типа <code>DevHnd a</code> никак не следует захвачен ли он текущим тредом, а значит проверка этого факта будет осуществляться в рантайме каждый раз когда мы будем модифицировать устройство и более того время от времени мы будем сталкиваться с ошибками времени исполнения.</li>
</ul>
<p>В общем случае, когда устройства захватываются и высвобождаются в произвольный момент времени ни первую, ни вторую проблему мы вероятнее всего не решим. Но если рассмотреть ситуацию когда все устройства захватываются и освобождаются одновременно ситуация перестаёт быть такой удручающей и внезапно укладывается в традиционный для haskell’я паттерн:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> c
    withSomething dev1 dev2 action <span class="fu">=</span> <span class="kw">do</span>
        alloc dev1 dev2
        v <span class="ot">&lt;-</span> action
        dealloc dev1 dev2
        return v</code></pre></div>
<p>Способов заблокировать несколько сущностей одновременно избежав дедлоков более одного, выберите по вкусу. Но <code>action</code> всё равно может содержать действия с устройствами, которые мы не захватили. Чтобы этого избежать можно сделать следующее:</p>
<ul>
<li>введём изоморфный <code>DevHnd a</code> тип <code>StaticHnd s a</code> с фантомным параметром <code>s</code> и приватную функцию <code>toStatic</code> делающую из первого второе;</li>
<li>введём изоморфную <code>IO a</code> монаду <code>Scope a</code>, а также функции для управления устройствами внутри этой монады через <code>StaticHnd s a</code>;</li>
<li>перепишем предыдущий код так:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c
    withSomething dev1 dev2 action <span class="fu">=</span> <span class="kw">do</span>
        alloc dev1 dev2
        v <span class="ot">&lt;-</span> action (toStatic dev1) (toStatic dev2)
        dealloc dev1 dev2
        return v</code></pre></div>
<p>Всё. Теперь следим за руками:</p>
<ul>
<li>изменять в нашем скоупе устройства через <code>DevHnd a</code> мы не можем, поскольку соответствующий мутатор не определён для <code>Scope a</code>;</li>
<li>создать <code>StaticHnd s a</code> мы можем только при помощи <code>withSomething</code>, поскольку <code>toStatic</code> не экспортирован наружу;</li>
<li>вернуть <code>StaticHnd s a</code> из <code>action</code> мы тоже не можем, поскольку функция не может вернуть значение любого типа, а фантомный параметр <code>s</code> передаваемых в неё аргументов объявлен как <code>forall</code>.</li>
</ul>
<p>Из всего этого следует что любая попытка использовать внутри нашего скоупа не захваченное устройство или устройство захваченное в другой скоуп (кроме родительского :^)) завершится <strong>ошибкой компиляции</strong>. Хорошо? Очень хорошо. Но на этом хорошее заканчивается и начинается Real World.</p>
<p>Приведённый код определён для двух устройств захватываемых в скоуп. Очевидным образом это довольно частный случай и этого мало. Также очевидно что функция <code>withSomething</code> содержит детали приватной реализации и должна быть чёрным ящиком. Есть несколько вариантов решения:</p>
<ul>
<li><p>Наиболее распространённым решением таких проблем в haskell’е это… унылая копипаста в результате которой получатся функции вида:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c

<span class="ot">withSomething2 ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c

<span class="ot">withSomething3 ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> c <span class="ot">-&gt;</span>
    (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s c <span class="ot">-&gt;</span> <span class="dt">Scope</span> d) <span class="ot">-&gt;</span> <span class="dt">IO</span> d</code></pre></div>
<p>И так до тех пор пока не надоест.</p></li>
<li><p>Также можно попробовать изобразить композицию.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">action <span class="fu">=</span>
    withSomething hnd1 <span class="fu">$</span> \sHnd1 <span class="ot">-&gt;</span>
        withSomething hnd2 <span class="fu">$</span> \sHnd2 <span class="ot">-&gt;</span>
            withSomething hnd3 <span class="fu">$</span> \sHnd3 <span class="ot">-&gt;</span> <span class="kw">do</span>
                doSomething sHnd1
                doSomething sHnd2
                doSomething sHnd3</code></pre></div>
<p>Но так мы теряем возможность захватывать устройства одной транзакцией (у каждого <code>withSomething</code> своя транзакция). В принципе это можно пофиксить введя ещё одну стадию заправки ракеты:</p>
<ul>
<li>вводим ещё одну монаду<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> (например Accure a) внутри которой можно делать только withSomething и run;</li>
<li>withSomething просто добавляет захват очередного устройства в готовящуюся транзакцию;</li>
<li>run запускает транзакцию и затем выполняет наш Scope.</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    action <span class="fu">=</span> accure <span class="fu">$</span>
        withSomething hnd1 <span class="fu">$</span> \sHnd1 <span class="ot">-&gt;</span>
            withSomething hnd2 <span class="fu">$</span> \sHnd2 <span class="ot">-&gt;</span>
                withSomething hnd3 <span class="fu">$</span> \sHnd3 <span class="ot">-&gt;</span> run <span class="fu">$</span> <span class="kw">do</span>
                    doSomething sHnd1
                    doSomething sHnd2
                    doSomething sHnd3</code></pre></div>
<ul>
<li><p>Наконец есть магия в стиле <code>Applicative</code> позволяющая писать что-то в духе:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(\v1 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1
(\v1 v2 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1 <span class="fu">&lt;*&gt;</span> doSome2
(\v1 v2 v3 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1 <span class="fu">&lt;*&gt;</span> doSome2 <span class="fu">&lt;*&gt;</span> doSome3</code></pre></div>
<p>Я даже видел как что-то подобное использовали в parsec’е, но от попыток натянуть это на свои типы у меня стабильно плавится мозг.</p></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>В данном случае это не так принципиально, но под управлением устройством разумеется подразумевается изменение его состояния.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Если у вас монада головного мозга конечно. Достаточно моноида, же.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Почему хаскель не подходит для скриптования?</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-06-13-why-haskell-bad-for-scripting.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-06-13-why-haskell-bad-for-scripting.html</id>
    <published>2014-06-13T00:00:00Z</published>
    <updated>2014-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Прежде чем обсуждать недостатки такого безусловно примечательного инструмента следует определиться с таким самоочевидным понятием как скриптование. Речь пойдёт в первую очередь о так называемых скриптах пользователя: небольших программах обеспечивающих интерфейс взаимодействия пользователя и более сложной системы. Например скрипты emacs’а, vim’а или даже acpid’а. В определённой степени можно говорить и командной оболочке операционной системы в принципе с некоторыми оговорками. Следует различать пользовательские скрипты и приложения для одного запуска: последние могут сколь угодно сложны, громоздки, запутаны, не очевидны и нечитабельны, поскольку читать их никто не будет и пишутся они обычно на одном дыхание, а со своими скриптами вам скорее всего ещё долгое время жить. Итак пользовательский скрипт это программа:</p>
<ul>
<li>предоставляющая интерфейс к более сложной системе чем система самого скрипта (в противном случае было бы проще поправить код системы)<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>;</li>
<li>небольшая (в противном случае кто кого скриптует и кто куда встроен<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>);</li>
<li>понятная (поскольку никто даже комментариев не пишет, не говоря уж про документацию);</li>
<li>как правило не критичная по производительности.</li>
</ul>
<p>Для таких задач традиционно используются shell, lua, js, scheme и прочие языки поразительно схожие с этими синтаксисом и семантикой (хотя некоторые умудряются для этого сравнительно успешно использовать целый python). Что объединяет эти языки? Слабая (у всех кроме scheme) динамическая типизация и позднее связывание. Оно и понятно, считается что если убрать из программы аннотацию типов то она станет выглядеть проще. Однако на сдачу мы получаем невозможность проверить хотя бы наличие вызываемых функций и существование используемых переменных не говоря уж о разумности применения одного к другому. Поскольку покрывать тестами подобного рода код будут немного позже того как к нему напишут документацию, то ситуация выглядит так себе.</p>
<p>При этом следует понимать, что статическая типизация и ранее связывание вообще говоря совсем не требуют аннотации типов. Компилятор зачастую может понять какой тип имеет то или иное выражение просто из контекста используемых функций. Компилятор может осуществлять вывод типов даже в таком языке как C++, где система типов вообще один из кругов Ада. Для более простого языка это осуществить ещё проще. Всё что ему нужно это твёрдая уверенность, что в середине выполнения программы не появятся новые функции, а семантика существующих типов не изменится. Довольно забавно, но для очерченных нами задач это практически всегда верно поскольку для решения простых задач такие динамические возможности едва ли понадобятся, а сложные мы вроде бы решать и не собирались<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p>Теперь посмотрим в свете наших задач на Haskell. Итак Haskell это ленивый, функциональный язык программирования с полиморфизмом на классах типов:</p>
<ul>
<li>вывод типов вместо динамической типизации: прекрасно работает;</li>
<li>функции высшего порядка вместо метапрограммирования: с учётом возможности определять операторы и тем что у основных конкурентов нет разделения на время компиляции и время исполнения, ок;</li>
<li>полиморфизм всего и вся вместо динамической диспетчеризации: вполне хватает;</li>
</ul>
<p>Плюс сопоставление с образцом, которое у конкурентов как правило отсутствует (ну кроме scheme и прочих лиспов). Что не так? А не так примерно следующее:</p>
<ul>
<li><p>Плохая стандартная библиотека. Многие вещи сделаны плохо поскольку пришли к нам из тех времён когда функциональные языки не умели готовить. Многие вещи сделаны плохо поскольку сделано с учётом особенностей реализации ghc. Так например несмотря на полиморфизм, большая часть функций Prelude мономорфна по используемому контейнеру. Или по используемому числовому типу. В той же стандартной библиотеке есть полиморфные функции, но они запрятаны в другие модули и часто создают конфликт имён, разрешение которого портит всю радость. Ну и за Monad который не Functor отдельное спасибо.</p></li>
<li><p>Сложная стандартная библиотека. В Prelude есть целых два типа для для обозначения целого знакового числа: Int (для числа размером в машинное слово) и Integer (для целого числа бесконечной точности). В Data.Int можно найти целые числа другого размера, а в Data.Word беззнаковые целые числа. Такое разнообразие типов безусловно не доведёт до добра скриптописателя. Он может <del>испугаться</del>начать решать проблемы производительности и не допишет свой скрипт никогда, поскольку будет писать стандартные функции для работы с Word8, отсутствующие в стандартной библиотеке. Для сравнение Lua использует только один тип — Number, который представляет собой закоробкованное число с плавающей запятой двойной точности (то есть Double).</p></li>
<li><p>Стандарт языка. Haskell2010 довольно простой язык у которого есть всё чтобы писать на нём программы. Однако программы эти будут содержать чёртову уйму бойлерплейта, интересных структур данных и коллизий пространств имён. Можно воспользоваться расширениями GHC. Код безусловно станет лаконичнее и яснее, но возникнут другие проблемы: выбор языковых средств (самый банальный пример это функциональные зависимости vs семейства типов), неоднозначности приводящие к трудности проверки типов, усложнение системы типов настолько что язык становится понятным вообще только компилятору. А ещё расширений так много что весь GHC-haskell не знает никто. Вместе с этим, стандартная библиотек старается по возможности избегать языковых расширений, что делает её именно такой как было описано в начале.</p></li>
<li><p>Реализация. Мне на сегодняшний день доводилось иметь дело с тремя реализациями haskell.</p>
<ul>
<li><p>GHC. Мы говорим haskell подразумеваем GHC. Мы говорим о стандартной библиотеке haskell подразумеваем base, а вовсе не haskell2010. Если вы хотите использовать существующие библиотеки то вам придётся использовать GHC. Впрочем это очень хороший компилятор с очень мощной и гибко настраиваемой рантайм-системой: в то время как кто-то всё ещё считает ссылки и никак не выпилит GIL, рантайм-система GHC вертит тысячами тредов и дефрагментирует кучу. Однако у этого всего есть оборотная сторона. GHC громоздок, как в сборке так и в виде библиотеки, а его рантайм избыточен и на небольших приложениях выглядит как лазерная атака из космоса для того чтобы поджарить тосты. Несмотря на все ухищрения и тюнинг рантайма ваше приложение вряд ли будет использовать меньше мегабайта под кучу. Не исключено, что больше тоже вряд ли, но тем не менее.</p></li>
<li><p>Jhc/Ajhc. Компилятор haskell в C. Если GHC придерживается традиционной модели компиляции, где есть раздельная компиляция различных единиц трансляции, а затем линковка, то Jhc проводит анализ, трансформации и компиляцию всего кода проекта. Полученный код на C отчаянно пытается управлять памятью при помощи выведенных регионов, но не справляется и всё в итоге опять скатывается в сканирующую сборку мусора. Эта реализация намного проще и компактнее, но по своей природе больше стремиться быть хаскелем для микроконтроллеров. Язык который она поддерживает — Haskell98 и несколько GHC-шных расширений того времени. Для нашей задачи она бесполезна.</p></li>
<li><p>Haste. Компилятор haskell в JS. Несмотря на жутковатый мапинг данных хаскеля в данные JS и время от времени возникающие проблемы с продолжениями, эта реализация ближе всего к нашим задачам. Haste использует фронтенд ghc и работает уже непосредственно с stg-кодом. Это решает проблему расширений, поскольку почти все они реализованы на уровне фронтенда. И всё же это 40 мегабайт компилятора и 13 — nodejs. Многовато. Кроме того v8 жрёт памяти как не в себя и встраивается только инженерами гугла.</p></li>
</ul></li>
<li><p>Слишком много приведений типов. Вот код на хаскеле:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  avrg xs <span class="fu">=</span> sum xs <span class="fu">/</span> length xs</code></pre></div>
<p>Среднее по списку значение это сумма всех значений в списке разделённая на длину списка. Всё хорошо? Нет. Оператор (/) не определён для целочисленного типа. Длинна списка это значение типа Int. Но даже если она будет Integer или сферический целочисленный тип в вакууме (Integral) ничего не изменится: делитель, делимое и результат должны быть одного типа, а в данном случае нас интересует именно нецелочисленный результат<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. Нужно писать как-то так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  avrg xs <span class="fu">=</span> sum xs <span class="fu">/</span> fromIntegral (length xs)</code></pre></div>
<p>В lua нет такой проблемы поскольку как уже писалось выше там всего один тип для записи чисел вообще. Однако в C (от которого в известной степени хаскель унаследовал примитивные типы) такой проблемы тоже нет: компилятор просто неявно приводит целое число к какой-нибудь плавучке.</p></li>
</ul>
<p>Пущей объективности ради следует заметить, что языки из круга конкурентов совсем не обязательно лишены подобных недостатков. И тем не менее будем считать что всё дело именно в них. Если всё перечисленное плохо и не нужно, то что нужно?</p>
<ul>
<li><p>Компилятор некого семантического надмножества Haskell2010. Стандарт довольно ядра языка довольно лаконичен. Возможно можно было бы исключить из него newtype поскольку он опять же заставляет задумываться, а в нашем случае это плохо. Из расширений стоит оставить:</p>
<ul>
<li><p>Многопараметрические классы типов и функциональные зависимости. Концептуальным решением было бы даже ограничиться классами где все параметры кроме одного зависимы<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p></li>
<li><p>Перегрузка оставшихся немногочисленных литералов. В стандарте перегружены числовые литералы и do-нотация. Соответственно остаётся перегрузить строковые (есть в ghc) и списки (есть в ghc).</p></li>
<li><p>GADT’ы. Упрощают описание древовидных структур и гетерогенных коллекций.</p></li>
<li><p>Data/Generic и прочее обобщённое программирование. В плане унылости мало что может потягаться с case’ом по двенадцати конструкторам, одиннадцать веток которого не делают ничего.</p></li>
<li><p>Управляемое неявное приведение типов.</p></li>
</ul></li>
<li><p>Компиляция неразделяемого кода. Шаблонный полиморфизм как в C++ и jhc. Тотальный инлайнинг и трансформация всего кода программы (интересно, насколько это реально в условиях just it time компиляции).</p></li>
<li><p>Кодогенератор в некую простую существующую переносимую виртуальную машину или даже язык. Предпочтительнее система со сканирующей сборкой мусора (что-то кондовое вроде mark &amp; sweep) и без jit-компилятора. Писать свою динамическую среду исполнения не стоит. Их уже итак больше чем нужно.</p></li>
<li><p>Простая стандартная библиотека.</p>
<ul>
<li><p>Было бы забавно обозвать монаду аппликативным функтором, но не понятно насколько это будет корректно.</p></li>
<li><p>Foldable и Traversable сделать классами от двух переменных где тип содержимого зависит от типа контейнера.</p></li>
<li><p>Не хранить строки в виде списка чаров. Это вызывает слишком много волнения и других строк. По большому счёту строка это массив кодпоинтов, но непонятно как тогда осуществлять паттерн-матчинг.</p></li>
<li><p>Стандартизованный механизм и формат исключений (вот уже GADT и в стандартной библиотеке).</p></li>
<li><p>Стандартные монадные трансформеры? Почему бы и нет. Плюс монада для логического вывода с бэктрекингом.</p></li>
<li><p>Регулярные выражения и комбинаторы парсеров. Последнее вообще киллер-фича функциональшины и ML-подобных.</p></li>
<li><p>Стандартные контейнеры типа Map, Set и так далее.</p></li>
<li><p>Парсеры для работы c json, xml, yaml.</p></li>
</ul></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Ну или у вас просто нет возможности поправить код системы. Но тогда горе побеждённым! Какой смысл обсуждать достоинства и недостатки brainfuck, если это единственный доступный вам способ изменить поведение вашей системы?<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Угу. Например в код emacs на elisp встроено небольшое ядро на C.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Существует спорное утверждение, что динамика очень нужна для создание EDSL’ей которые действительно позволяют повысить простоту кода и довольно эффективно съесть сложность и громоздкость кода.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Иначе у нас бы использовалось целочисленное деление.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Да-да. Это семейства типов. Но они выглядят более громоздкими. Функциональные зависимости более лаконичны что-ли.<a href="#fnref5">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>e</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-05-24-e.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-05-24-e.html</id>
    <published>2014-05-24T00:00:00Z</published>
    <updated>2014-05-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Четыре года назад, я радовался работе с бесконечными списками и вычислял e суммируя ряд Тейлора так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> map (\x <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">/</span> fac x) [<span class="dv">0</span><span class="fu">..</span>]
    <span class="kw">where</span>
        fac n <span class="fu">=</span> foldl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>n]
        sum (x<span class="fu">:</span>xs) <span class="fu">=</span> sumtr (x<span class="fu">:</span>xs) <span class="dv">0</span>
        sumtr (x<span class="fu">:</span>xs) acc
            <span class="fu">|</span> (acc <span class="fu">==</span> acc <span class="fu">+</span> x) <span class="fu">=</span> acc
            <span class="fu">|</span> otherwise <span class="fu">=</span> sumtr xs (x <span class="fu">+</span> acc)</code></pre></div>
<p>Случайно найдя предыдущий сниппет и смахнув слезу умиления, я переписал суммирование уже со знанием стандартной библиотеки.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> takeWhile (<span class="fu">/=</span><span class="dv">0</span>) <span class="fu">$</span> map (\v <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">/</span> product [<span class="dv">1</span><span class="fu">..</span>v]) [<span class="dv">0</span><span class="fu">..</span>]</code></pre></div>
<p>Проблема в том, что этот вариант аллоцировал в 10 раз больше памяти чем первый. Стало как-то неудобно и я заменил вычисление факториала для каждого нового члена ряда Тейлора на вычисление непрерывного списка факториалов, где каждый следующий элемент умножение номера члена ряда на значение предыдущего элемента.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> takeWhile (<span class="fu">/=</span><span class="dv">0</span>) <span class="fu">$</span> map (<span class="dv">1</span><span class="fu">/</span>) <span class="fu">$</span> scanl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>]</code></pre></div>
<p>Количество аллоцированной памяти вышло на уровень первого варианта. Однако в первом варианте у нас используется наивный факториал и он всё равно работает замечательно. Разница состоит в том, что первый вариант суммирует ряд до тех пор пока сумма изменяется, а третий — до тех пор пока n-ый член ряда не станет нулём. Любому кто знаком с числами с плавающей запятой понятно что первое условие выполнится быстрее второго. Попробуем использовать именно первое условие. Для этого из бесконечного списка факториалов получим бесконечный список сумм, выделим пары текущая сумма/следующая сумма и будем разматывать список до тех пор пока суммы не равны. Последняя сумма и есть наша.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> fst <span class="fu">$</span> last <span class="fu">$</span> takeWhile (uncurry (<span class="fu">/=</span>)) <span class="fu">$</span> (\v <span class="ot">-&gt;</span> zip v (tail v)) <span class="fu">$</span> scanl1 (\v0 v1 <span class="ot">-&gt;</span> v0 <span class="fu">+</span> <span class="dv">1</span> <span class="fu">/</span> v1) <span class="fu">$</span> scanl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>]</code></pre></div>
<p>Мы наконец заметно превзошли по выделенной памяти первый вариант. Но не в 10 раз, а в полтора и ценой дополнительного времени на сборку мусора. Это скажем так себе результат.</p>
<p>P.S: Продолжение следует.</p>]]></summary>
</entry>

</feed>
