<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>All your need is love and a little bit of LSD — tagged haskell</title>
    <link href="https://ndtimofeev.github.io/ru/tags/haskell.xml" rel="self" />
    <link href="https://ndtimofeev.github.io" />
    <id>https://ndtimofeev.github.io/ru/tags/haskell.xml</id>
    <author>
        <name>Nikita Timofeev</name>
        <email>ndtimofeev@gmail.com</email>
    </author>
    <updated>2016-05-20T00:00:00Z</updated>
    <entry>
    <title>О том как избежать успеха и как не избежать успеха…</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2016-05-20-GHC8-callstack.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2016-05-20-GHC8-callstack.html</id>
    <published>2016-05-20T00:00:00Z</published>
    <updated>2016-05-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="успех-сам-себя-не-избежит">Успех сам себя не избежит</h2>
<p>При всём богатстве возможностей в Haskell регулярно возникают проблемы с вещами, которые кажутся совершенно элементарными. Например получить стек вызовов в случае ошибки. Причём не то что бы его нельзя получить совсем, наоборот есть как минимум два ортогональных способа, но всё это сопряжено с таким количеством сложностей и условий, что проще воткнуть в нужные места printf’ы или густо обмазываться препроцессором. Особенно грустно дело с этим обстояло в ghci.</p>
<p>И вот для пользователей ghci наступает <a href="http://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html">революция</a>. Казалось бы страдания остались в прошлом, а <code>error</code> и <code>undefined</code> обрели практическое применение. Однако первая же попытка использовать это в массиве написанного кода обернулась неудачей: <code>error</code> и <code>undefined</code> выдавали стек вызовов, а броски исключения — нет. Сначала я подозревал себя в том, что куда-то не включил профилировочную информацию или как-то не так использую ImplicitParams, но потом я просто полез в код.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Err.hs:77</span>
<span class="ot">    undefined ::</span> forall (<span class="ot">r ::</span> <span class="dt">RuntimeRep</span>)<span class="fu">.</span> forall (<span class="ot">a ::</span> <span class="dt">TYPE</span> r)<span class="fu">.</span>
                 <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> a
    undefined <span class="fu">=</span>  error <span class="st">&quot;Prelude.undefined&quot;</span></code></pre></div>
<p>Тут всё понятно: <code>undefined</code> это такой частный случай <code>error</code> для тех кому не хватило фантазии написать осмысленное сообщение. Улыбаемся “Prelude.undefined” и двигаемся дальше.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Err.hs:36</span>
<span class="ot">    error ::</span> forall (<span class="ot">r ::</span> <span class="dt">RuntimeRep</span>)<span class="fu">.</span> forall (<span class="ot">a ::</span> <span class="dt">TYPE</span> r)<span class="fu">.</span>
             <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> a
    error s <span class="fu">=</span> raise<span class="fu">#</span> (errorCallWithCallStackException s <span class="fu">?</span>callStack)</code></pre></div>
<p>Тут в принципе ожидалось увидеть что-то вроде <code>throw . ErrorCall</code>, но не оно. С другой стороны <code>raise#</code> это такой primop, который реализует throw, так что <code>errorCallWithCallStackException</code> должен быть таким замысловатым способом сконструировать исключение. За подтверждением лезем в <code>GHC.Exception</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Exception.hs:171</span>
    <span class="kw">data</span> <span class="dt">ErrorCall</span> <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> <span class="dt">String</span> <span class="dt">String</span>
        <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)

    pattern <span class="dt">ErrorCall</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ErrorCall</span>
    pattern <span class="dt">ErrorCall</span> err <span class="ot">&lt;-</span> <span class="dt">ErrorCallWithLocation</span> err _ <span class="kw">where</span>
      <span class="dt">ErrorCall</span> err <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> err <span class="st">&quot;&quot;</span>

    <span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">ErrorCall</span>

    <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">ErrorCall</span> <span class="kw">where</span>
      showsPrec _ (<span class="dt">ErrorCallWithLocation</span> err <span class="st">&quot;&quot;</span>) <span class="fu">=</span> showString err
      showsPrec _ (<span class="dt">ErrorCallWithLocation</span> err loc) <span class="fu">=</span> showString (err <span class="fu">++</span> <span class="ch">&#39;\n&#39;</span> <span class="fu">:</span> loc)

<span class="ot">    errorCallException ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeException</span>
    errorCallException s <span class="fu">=</span> toException (<span class="dt">ErrorCall</span> s)</code></pre></div>
<p>Первое что нас удивляет: конструктор <code>ErrorCall</code> теперь называется как-то по другому и таскает не одну строчку, а два. Впрочем если посмотреть <a href="http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html">тут</a> то фокус с конструктором и синонимом становится понятен.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Exception.hs:187</span>
<span class="ot">    errorCallWithCallStackException ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">CallStack</span> <span class="ot">-&gt;</span> <span class="dt">SomeException</span>
    errorCallWithCallStackException s stk <span class="fu">=</span> unsafeDupablePerformIO <span class="fu">$</span> <span class="kw">do</span>
      ccsStack <span class="ot">&lt;-</span> currentCallStack
      <span class="kw">let</span>
        implicitParamCallStack <span class="fu">=</span> prettyCallStackLines stk
        ccsCallStack <span class="fu">=</span> showCCSStack ccsStack
        stack <span class="fu">=</span> intercalate <span class="st">&quot;\n&quot;</span> <span class="fu">$</span> implicitParamCallStack <span class="fu">++</span> ccsCallStack
      return <span class="fu">$</span> toException (<span class="dt">ErrorCallWithLocation</span> s stack)</code></pre></div>
<p>Теперь собственно виновник торжества. Получаем явный стек в качестве переменной, достаём стек профилировщика хакнув IO, красиво рисуем, склеиваем, запихиваем в расширенный <code>ErrorCall</code> вместе с сообщением, заворачиваем в <code>SomeException</code>. Если посмотреть на инстанс <code>Show</code> для <code>ErrorCall</code>, то можно увидеть код, который рисует стек если соответствующее поле заполнено. Снаружи никаких изменений в <code>ErrorCall</code> не видно. Отличный пример того как можно при помощи паттерн-синонимов в GHC8 можно изобразить инкапсуляцию. Теперь смотрим на <code>throw</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Exception.hs:166</span>
<span class="ot">    throw ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> a
    throw e <span class="fu">=</span> raise<span class="fu">#</span> (toException e)</code></pre></div>
<p>Ну конечно. Тут просто неоткуда взяться стек-трейсу. Да как бы он хранился в исключение произвольного типа? Разве что как-то так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">data</span> <span class="dt">SomeException</span> <span class="kw">where</span>
        <span class="dt">SomeExceptionWithLocation</span><span class="ot"> ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">SomeException</span>

    pattern <span class="dt">SomeException</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">SomeException</span>
    pattern <span class="dt">SomeException</span> err <span class="ot">&lt;-</span> <span class="dt">SomeExceptionWithLocation</span> _ err <span class="kw">where</span>
      <span class="dt">SomeException</span> err <span class="fu">=</span> <span class="dt">SomeExceptionWithLocation</span> <span class="st">&quot;&quot;</span> err</code></pre></div>
<h2 id="работать-вокруг">Работать вокруг</h2>
<p>Разобраться с тем почему ничего не работает хорошо, но было бы ещё лучше понять что нужно сделать чтобы оно заработало. В данном случае ответ простой: модифицировать стандартную библиотеку так, чтобы <code>SomeException</code> таскал за собой информацию о стеке вызовов[^1]. Однако, увы, у меня такой возможности нет. Можно вместо <code>SomeException</code> модифицировать типы исключений, которые выбрасываются в коде. Тогда придётся ещё и написать функцию, которая будет заполнять новый тип нужными данными. Также будем исходить из соображения, что нам лениво явным образом включать информацию о стеке вызовов в каждый тип исключение и мы напишем обёртку для всех исключений сразу.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE ImplicitParams #-}</span>

<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Control.Exception</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Typeable</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">GHC.Stack</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">System.IO.Unsafe</span>

<span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">CallStackException</span> <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="dt">CallStackException</span><span class="ot"> ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">CallStackException</span>

<span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">CallStackException</span></code></pre></div>
<p>Пока похоже на правду.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">CallStackException</span> <span class="kw">where</span>
<span class="fu">&gt;</span>     show (<span class="dt">CallStackException</span> e <span class="st">&quot;&quot;</span>)    <span class="fu">=</span> show e
<span class="fu">&gt;</span>     show (<span class="dt">CallStackException</span> e stack) <span class="fu">=</span> show e <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span> stack</code></pre></div>
<p>Наша обёртка не несёт никакого смысла для получателя исключения, так что показывать нам особо нечего. Если исключение прилетело без стек-трейса показываем только вложенное исключение. Если вместе со стек-трейсом то вложенное исключение и стек-трейс на следующей строке. Теперь нам нужен аналог <code>throwIO</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> throwIO&#39; ::</span> (<span class="dt">HasCallStack</span>, <span class="dt">Exception</span> e) <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="fu">&gt;</span> throwIO&#39; e <span class="fu">=</span> <span class="kw">do</span>
<span class="fu">&gt;</span>     stack <span class="ot">&lt;-</span> currentCallStack
<span class="fu">&gt;</span>     throwIO <span class="fu">$</span> <span class="dt">CallStackException</span> e <span class="fu">$</span> <span class="kw">if</span> stack <span class="fu">/=</span> []
<span class="fu">&gt;</span>         <span class="kw">then</span> prettyCallStack <span class="fu">?</span>callStack <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span> renderStack stack
<span class="fu">&gt;</span>         <span class="kw">else</span> prettyCallStack <span class="fu">?</span>callStack</code></pre></div>
<p>Вычитываем текущий стек вызовов профилировщика, выбрасываем наружу исключение в обёртке со стеком состоящем из <code>ImplicitParams</code>-стека и стека профилировщика, если он не пустой. Ничего интересного. Давайте для красоты добавим:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> throw&#39; ::</span> (<span class="dt">HasCallStack</span>, <span class="dt">Exception</span> e) <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> a
<span class="fu">&gt;</span> throw&#39; <span class="fu">=</span> unsafeDupablePerformIO <span class="fu">.</span> throwIO&#39;</code></pre></div>
<p>Теперь можно бросить произвольное исключение и оно будет снабжено стеком вызовов. В принципе это уже весьма неплохо, поскольку в 80% случаев если обработка исключений и осуществляется, то на уровне <code>onException</code>. <code>bracket</code> и прочего <code>finaly</code>. Но положем мы всё же хотим ловить исключения по типу. У нас ничего не выйдет, поскольку в <code>SomeException</code> завёрнуто исключение не того типа который мы ловим, а типа-обёртки. Можно решить эту проблему двумя способами. Во-первых можно почитать документацию в <code>Control.Exception</code> и перегрузить <code>toException</code> и <code>fromException</code> для интересующих нас типов исключений таким образом чтобы он учитывал наличие обёртки. Но это придётся делать для каждого типа-исключения. Во-вторых мы можем написать свой волшебный <code>catch</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> exceptionLoop ::</span> (<span class="dt">Exception</span> a, <span class="dt">Exception</span> e) <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> b
<span class="fu">&gt;</span> exceptionLoop ex f abort
<span class="fu">&gt;</span>     <span class="fu">|</span> <span class="dt">Just</span> (<span class="dt">SomeException</span> inner)        <span class="ot">&lt;-</span> cast ex <span class="fu">=</span> exceptionLoop inner f abort
<span class="fu">&gt;</span>     <span class="fu">|</span> <span class="dt">Just</span> (<span class="dt">CallStackException</span> inner _) <span class="ot">&lt;-</span> cast ex <span class="fu">=</span> exceptionLoop inner f abort
<span class="fu">&gt;</span>     <span class="fu">|</span> <span class="dt">Just</span> v                            <span class="ot">&lt;-</span> cast ex <span class="fu">=</span> f v
<span class="fu">&gt;</span>     <span class="fu">|</span> otherwise                                    <span class="fu">=</span> abort

<span class="fu">&gt;</span><span class="ot"> catch&#39; ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="fu">&gt;</span> catch&#39; eval f <span class="fu">=</span> catch eval <span class="fu">$</span>
<span class="fu">&gt;</span>      \err<span class="fu">@</span>(<span class="dt">SomeException</span> top) <span class="ot">-&gt;</span> exceptionLoop top f (throwIO err)</code></pre></div>
<p>Ловим все исключения и пытаемся их привести либо к тому типу который ждёт наш обработчик, либо к типам обёрткам. Если нашли обёртку, спускаемся уровнем ниже, если нашли нужный тип — обрабатываем, если не нашли ничего перебрасываем ровно то что получили с сохранением стека. Всё. Мы победили.</p>
<p>Радость правда омрачает то, что у нас есть свои собственные особые функции для того чтобы бросать и ловить исключения и нужно модифицировать весь существующий код. Конечно если он с самого начала был написан с помощью пакета <a href="http://hackage.haskell.org/package/exceptions"><code>exceptions</code></a>, который вводит классы позволяющие перегрузить <code>throwIO</code> и <code>catch</code> для произвольной монады то ситуация выглядит существенно лучше, но модифицировать код для того чтобы его было проще отлаживать всё равно придётся. Кроме того, останутся вызовы <code>throw</code> в коде, который нами не управляется (например в стандартной библиотеке ввода-вывода). Это фейл.</p>
<h2 id="проблемы">Проблемы</h2>
<p>Теперь, когда всем стало ясно, что во всём виноваты мейнтейнеры стандартной библиотеки стоит отметить пару проблем, которые так просто не решить.</p>
<ul>
<li><p>Нарушение ссылочной прозрачности. Рассмотрим вот такой код:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">eval <span class="ot">`catch`</span> (\ex<span class="fu">@</span>(<span class="dt">T</span> v) <span class="ot">-&gt;</span> <span class="kw">if</span> pred v
    <span class="kw">then</span> makeGood
    <span class="kw">else</span> throwIO ex)</code></pre></div>
<p>Нам кажется что в ветке <code>else</code> мы ничего не делаем, просто перебрасываем исключение, которое получили незаметно для кода выше по стеку. На самом деле мы только что обрезали стек вызовов до глубины <code>catch</code>. Конечно можно решить что всё ок и так нам и надо, но это не отменяет того что мы имеем малоочевидный побочный эффект.</p></li>
<li><p>А ещё есть асинхронные исключения, для которых вся эта ерунда вообще не применима. Ну то есть в <code>throwTo</code> безусловно можно вычитать текущий стек-трейс, но какой он имеет смысл для процесса в который исключение бросается? Можно опять же решить что всё ок и для асинхронного исключения стек вызовов не так уж и важен, но если кто-то из обработчиков этого исключения перебросит его как в предыдущем примере то в итоге мы получим стек вызовов означающий примерно ничего.</p></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Моему другу Серёже Алирзаеву посвящается…</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2016-01-26-l29ah.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2016-01-26-l29ah.html</id>
    <published>2016-01-26T00:00:00Z</published>
    <updated>2016-01-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Понапридумывали расширений!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>
<span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE DeriveTraversable #-}</span>

<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Foldable</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Proxy</span>

<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Peano</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Peano</span>
<span class="fu">&gt;</span>     <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">FixedList</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) a <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">FixedList</span> <span class="dt">Z</span> a
<span class="fu">&gt;</span><span class="ot">     (:.) ::</span> a <span class="ot">-&gt;</span> <span class="dt">FixedList</span> n a <span class="ot">-&gt;</span> <span class="dt">FixedList</span> (<span class="dt">S</span> n) a

<span class="fu">&gt;</span> <span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:.</span>

<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">FixedList</span> n a)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">FixedList</span> n a)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">FixedList</span> n)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Foldable</span> (<span class="dt">FixedList</span> n)
<span class="fu">&gt;</span> <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Traversable</span> (<span class="dt">FixedList</span> n)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nill</span>)
<span class="co">-- (2 :. 3 :. 4 :. Nill)</span>

λ<span class="fu">&gt;</span> find (<span class="fu">==</span><span class="dv">2</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nill</span>)
<span class="co">-- Just 2</span>

λ<span class="fu">&gt;</span> mapM_ print (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nill</span>)
<span class="co">-- 1</span>
<span class="co">-- 2</span>
<span class="co">-- 3</span></code></pre></div>
<p>Вроде норм.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sumOurSpecialFixedList ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span>
     <span class="dt">FixedList</span>
       (<span class="ch">&#39;S</span>
          (<span class="ch">&#39;S</span>
             (<span class="ch">&#39;S</span>
                (<span class="ch">&#39;S</span>
                   (<span class="ch">&#39;S</span>
                      (<span class="ch">&#39;S</span>
                         (<span class="ch">&#39;S</span>
                            (<span class="ch">&#39;S</span>
                               (<span class="ch">&#39;S</span>
                                  (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S &#39;</span><span class="dt">Z</span>))))))))))))))))))))
       a
     <span class="ot">-&gt;</span> a
sumOurSpecialFixedList <span class="fu">=</span> sum</code></pre></div>
<p>Чо?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">type</span> family <span class="dt">N2P</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="dt">N2P</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Z</span>
<span class="fu">&gt;</span>     <span class="dt">N2P</span> n <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">N2P</span> (n <span class="fu">-</span> <span class="dv">1</span>))

<span class="fu">&gt;</span> <span class="kw">type</span> <span class="dt">FList</span> n <span class="fu">=</span> <span class="dt">FixedList</span> (<span class="dt">N2P</span> n)</code></pre></div>
<p>Чо?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sumOurSpecialFixedList ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">FList</span> <span class="dv">20</span> a <span class="ot">-&gt;</span> a
sumOurSpecialFixedList <span class="fu">=</span> sum</code></pre></div>
<p>Ок.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>) <span class="fu">!!</span> <span class="dv">1</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>
    <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> ‘[a]’
                with actual <span class="kw">type</span> ‘<span class="dt">FixedList</span> (<span class="ch">&#39;S (&#39;</span><span class="dt">S</span> (<span class="ch">&#39;S &#39;</span><span class="dt">Z</span>))) <span class="dt">Integer</span>’
    <span class="dt">Relevant</span> bindings include<span class="ot"> it ::</span> a (bound at <span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">1</span>)
    <span class="dt">In</span> the first argument <span class="kw">of</span> ‘(<span class="fu">!!</span>)’, namely ‘(<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>)’
    <span class="dt">In</span> the expression<span class="fu">:</span> (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>) <span class="fu">!!</span> <span class="dv">1</span>
    <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>) <span class="fu">!!</span> <span class="dv">1</span></code></pre></div>
<p>Ле!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">type</span> family <span class="dt">P2N</span> (<span class="ot">n ::</span> <span class="dt">Peano</span>) <span class="kw">where</span>
<span class="fu">&gt;</span>     <span class="dt">P2N</span> <span class="dt">Z</span>     <span class="fu">=</span> <span class="dv">0</span>
<span class="fu">&gt;</span>     <span class="dt">P2N</span> (<span class="dt">S</span> n) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dt">P2N</span> n

<span class="fu">&gt;</span><span class="ot"> findex ::</span> (<span class="dt">KnownNat</span> n, n <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&lt;=</span> <span class="dt">P2N</span> m) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> n <span class="ot">-&gt;</span> <span class="dt">FixedList</span> m a <span class="ot">-&gt;</span> a
<span class="fu">&gt;</span> findex proxy xs <span class="fu">=</span> toList xs <span class="fu">!!</span> fromInteger (natVal proxy)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XDataKinds</span>
λ<span class="fu">&gt;</span> findex  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">2</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>)
<span class="co">-- 3</span>
λ<span class="fu">&gt;</span> findex  (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">0</span>) (<span class="dv">1</span> <span class="fu">:.</span> <span class="dv">2</span> <span class="fu">:.</span> <span class="dv">3</span> <span class="fu">:.</span> <span class="dt">Nil</span>)
<span class="co">-- 1</span></code></pre></div>
<p>Пук. Пёрд. Среньк. Ко-ко-ко-зависимые-типы.</p>]]></summary>
</entry>
<entry>
    <title>O Managed и MonadCatch или что делать если нельзя, но очень хочется…</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2016-01-19-managed.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2016-01-19-managed.html</id>
    <published>2016-01-19T00:00:00Z</published>
    <updated>2016-01-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Есть такой классный человек — <a href="http://www.haskellforall.com/">Gabriel Gonzalez</a>. Он делает с Haskell довольно классные и простые вещи. Зачастую ими совершенно никто не пользуется, но тем не менее они есть и на них стоит посмотреть хотя бы для того чтобы проникнуться и не делать из Хаскеля промышленную Яву. В частности именно он является автором пакета <a href="http://hackage.haskell.org/package/managed">managed</a>, который позволяет <del>экономить отступы</del> управлять ресурсами довольно своеобразным способом.</p>
<h2 id="foo">Что такое Managed?</h2>
<p>Положим у есть файл. и нужно с ним сделать что-то хорошее. Файл надо открыть, получить его <code>Handle</code>, сделать с ним что-то и закрыть. Примерно так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    hnd <span class="ot">&lt;-</span> openFile <span class="st">&quot;path/to/file&quot;</span> <span class="dt">ReadMode</span>
    hPutStrLn hnd <span class="st">&quot;\1051\1103\1093, \1080\1076\1080 \1085\1072 \1093\1091\1081&quot;</span>
    hClose hnd</code></pre></div>
<p>Что будет если попытаться записать что-то в файл открытый на чтение? Вылетит исключение и если его не поймать — тред упадёт. Если он главный и единственный можно заканчивать разговор. Если же есть друге треды то видимо где-то остался висеть открытый файл. Плохо. Хорошо, пишем так.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    hnd <span class="ot">&lt;-</span> openFile <span class="st">&quot;path/to/file&quot;</span> <span class="dt">ReadMode</span>
    hPutStrLn hnd <span class="st">&quot;\1051\1103\1093, \1080\1076\1080 \1085\1072 \1093\1091\1081&quot;</span> <span class="ot">`onException`</span> hClose hnd
    hClose hnd</code></pre></div>
<p>Уже лучше. Правда может прилететь асинхронное исключение из соседнего треда, которое может успеть помешать закрыть файл, но от него можно обезопасить себя при помощи mask. А можно обнаружить в стандартной библиотеке функцию <code>withFile</code>, которая всё это делает за вас примерно так.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    withFile <span class="st">&quot;path/to/file&quot;</span> <span class="dt">ReadMode</span> <span class="fu">$</span> \hnd <span class="ot">-&gt;</span> hPutStrLn hnd <span class="st">&quot;\1051\1103\1093, \1080\1076\1080 \1085\1072 \1093\1091\1081&quot;</span></code></pre></div>
<p>Всё прекрасно до тех пор пока нам не нужно записать содержимое одного файла в другой или даже записать содержимое двух файлов в один:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    withFile <span class="st">&quot;path/to/file&quot;</span> <span class="dt">ReadMode</span> <span class="fu">$</span> \hnd <span class="ot">-&gt;</span>
        withFile <span class="st">&quot;path/to/file1&quot;</span> <span class="dt">ReadMode</span> <span class="fu">$</span> \hnd1 <span class="ot">-&gt;</span>
            withFile <span class="st">&quot;path/to/file2&quot;</span> <span class="dt">ReadMode</span> <span class="fu">$</span> \hnd2 <span class="ot">-&gt;</span> <span class="kw">do</span>
                hGetContents hnd  <span class="fu">&gt;&gt;=</span> hPutStr hnd2
                hGetContents hnd1 <span class="fu">&gt;&gt;=</span> hPutStr hnd2</code></pre></div>
<p>Уже не так красиво. Хорошо, можно накидать волшебную стейт-монаду содержащую хэндлеры финализирующие действия аллоцирующие ресурсы.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    runMagicState <span class="fu">$</span> <span class="kw">do</span>
        hnd  <span class="ot">&lt;-</span> smartFileOpen <span class="st">&quot;path/to/file&quot;</span>  <span class="dt">ReadMode</span>
        hnd1 <span class="ot">&lt;-</span> smartFileOpen <span class="st">&quot;path/to/file1&quot;</span> <span class="dt">ReadMode</span>
        hnd2 <span class="ot">&lt;-</span> smartFileOpen <span class="st">&quot;path/to/file2&quot;</span> <span class="dt">ReadMode</span>
        liftIO <span class="fu">$</span> hGetContents hnd  <span class="fu">&gt;&gt;=</span> hPutStr hnd2
        liftIO <span class="fu">$</span> hGetContents hnd1 <span class="fu">&gt;&gt;=</span> hPutStr hnd2</code></pre></div>
<p>Можно сделать так чтобы смарт-конструкторы возвращали ещё и универсальный ключ, добавить подсчёт ссылок, передавать ресурсы между тредами, освобождать в рантайме и вообще сделать свой собственный <a href="http://hackage.haskell.org/package/resourcet">resourcet</a>. Правда придётся писать для всех ресурсов смарт-конструкторы регистрирующие финализаторы, которые можно использовать только с волшебной монадой, что немного расстраивает. А можно решить что во варианте с <code>withFile</code> итак всё было хорошо кроме способа соединения вычислений между собой и поискать тут монаду более хитрую монаду.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">newtype</span> <span class="dt">Managed</span> a <span class="fu">=</span> <span class="dt">Managed</span> {<span class="ot"> with ::</span> forall r <span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> <span class="dt">IO</span> r }

    <span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Managed</span> <span class="kw">where</span>
        fmap f mx <span class="fu">=</span> <span class="dt">Managed</span> <span class="fu">$</span> \return_ <span class="ot">-&gt;</span>
            with mx <span class="fu">$</span> \x <span class="ot">-&gt;</span>
            return_ <span class="fu">$</span> f x

    <span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Managed</span> <span class="kw">where</span>
        pure r    <span class="fu">=</span> <span class="dt">Managed</span> <span class="fu">$</span> \return_ <span class="ot">-&gt;</span> return_ r

        mf <span class="fu">&lt;*&gt;</span> mx <span class="fu">=</span> <span class="dt">Managed</span> <span class="fu">$</span> \return_ <span class="ot">-&gt;</span>
            with mf <span class="fu">$</span> \f <span class="ot">-&gt;</span>
            with mx <span class="fu">$</span> \x <span class="ot">-&gt;</span>
            return_ <span class="fu">$</span> f x

    <span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Managed</span> <span class="kw">where</span>
        return   <span class="fu">=</span> pure

        ma <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Managed</span> <span class="fu">$</span> \return_ <span class="ot">-&gt;</span>
            with ma <span class="fu">$</span> \a <span class="ot">-&gt;</span>
            with (f a) <span class="fu">$</span> \b <span class="ot">-&gt;</span>
            return_ b

    <span class="kw">instance</span> <span class="dt">MonadIO</span> <span class="dt">Managed</span> <span class="kw">where</span>
        liftIO m <span class="fu">=</span> <span class="dt">Managed</span> <span class="fu">$</span> \return_ <span class="ot">-&gt;</span> <span class="kw">do</span>
            v <span class="ot">&lt;-</span> m
            return_ v</code></pre></div>
<p>В принципе это примерно весь код, который необходим для работы <code>Managed</code>. Теперь можно писать код как-то так.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    with <span class="fu">$</span> <span class="kw">do</span>
        hnd  <span class="ot">&lt;-</span> <span class="dt">Managed</span> <span class="fu">$</span> withFile <span class="st">&quot;path/to/file&quot;</span> <span class="dt">ReadMode</span>
        hnd1 <span class="ot">&lt;-</span> <span class="dt">Managed</span> <span class="fu">$</span> withFile <span class="st">&quot;path/to/file1&quot;</span> <span class="dt">ReadMode</span>
        hnd2 <span class="ot">&lt;-</span> <span class="dt">Managed</span> <span class="fu">$</span> withFile <span class="st">&quot;path/to/file2&quot;</span> <span class="dt">ReadMode</span>
        liftIO <span class="fu">$</span> hGetContents hnd  <span class="fu">&gt;&gt;=</span> hPutStr hnd2
        liftIO <span class="fu">$</span> hGetContents hnd1 <span class="fu">&gt;&gt;=</span> hPutStr hnd2</code></pre></div>
<p>Плюсом данного подхода является использование готовых смарт-конструкторов, написанных автором библиотеки, отсутствие явного стейта, который можно было бы как-то хитро сломать и простота кода. Минусом скромность возможностей: нельзя передать ресурс во владение другому треду, нельзя запустить финализацию раньше времени<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Примерно как <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> в C++.</p>
<h2 id="monadcatch-и-monadmask">MonadCatch и MonadMask</h2>
<p>Наступило счастье? Скорее всего нет. В реальной жизни почти всегда почему-то недостаточно дёрнуть финализатор перед смертью. Ситуаций где это достаточно и необходимо станет совсем не много. Если начать задумываться о том что в ходе выполнения программы возникают исключения, то почему-то сразу начинает требоваться ловить эти исключения и передавать в другой тред, откладывать исключения до момента пока не закончится вон та очень важная операция и многое другое, типа таймеров, юзер-интерапта и прочего <code>KillThread</code>. Также очень часто приходится работать не с одной монадой, а со стеком монадных трансформеров. Трансформер на вершине стека не зависит от конкретной монады нижнего уровня и опирается лишь на констрейнты, которыми он её ограничивает. Итого: нужно обрабатывать исключения в рамках <code>Managed</code>, а не только вызывать финализацию, нужны инстансы <code>MonadCatch</code> и <code>MonadMask</code> для <code>Managed</code>. А вот тут возникают проблемы.</p>
<ul>
<li><p>В числе законов <code>MonadCatch</code> указан только:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">catch (throwM e) f <span class="fu">=</span> f e</code></pre></div>
<p>который выполнить довольно легко, но если не обеспечить также поведение вида:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">catch (try meval) f <span class="fu">&gt;&gt;</span> throwM e <span class="fu">=</span> throwM e</code></pre></div>
<p>то скорее всего люди столкнувшись с таким <code>catch</code>’ем будут озадачены настолько что отрубят автору такого инстанса руки. Но для <code>Managed</code> следующее связанное выражение выполняется не после текущего, а внутри. Так что если обернуть его целиком в <code>catch</code>, то мы заодно обернём в <code>catch</code> и все последующие связанные выражения в этой монаде и получится что-то вроде такого поведения.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">catch (try meval) f <span class="fu">&gt;&gt;</span> throwM e <span class="fu">=</span> f e</code></pre></div></li>
<li><p>Если оборачивать в <code>catch</code> <code>Managed</code>-выражение, должны быть перехвачены исключение возникшие только до следующего связывания или в финализаторе тоже?</p></li>
</ul>
<p>Можно попытаться вспомнить что <code>Managed</code>, это в теории такой специализированный вид монады <code>ContT</code> из <a href="http://hackage.haskell.org/package/transformers">transfomers</a>, а в <a href="http://hackage.haskell.org/package/exceptions">exceptions</a> есть необходимые инстансы для стандартных монад. Но если посмотреть туда, станет понятно что <code>ContT</code> чуть ли не единственная монада оттуда для которой Эдвард Кметт не придумал <code>MonadCatch</code> и <code>MonadMask</code>. В общем случае решить эти вопросы довольно трудно, традиционно принято их не решать вообще и пользоваться либо <a href="http://hackage.haskell.org/package/managed">managed</a>, либо <a href="http://hackage.haskell.org/package/exceptions">exceptions</a>.</p>
<h2 id="костыли">Костыли</h2>
<p>Что делать если очень хочется? Для начала попробуем себя уговорить, что проблемы нет. Начнём со второго вопроса. Итак, по сути каждое вычисление в <code>Managed</code> состоит из самого «вычисления» и некоего «финализатора», который выполнится после того как выполнятся все связанные вычисления.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="dt">Managed</span> <span class="fu">$</span> \следующее <span class="ot">-&gt;</span> вычисление <span class="fu">&gt;&gt;=</span> следующее <span class="fu">&gt;&gt;</span> финализатор</code></pre></div>
<p>Традиционный <code>withSome</code> выглядит примерно так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    withSome eval <span class="fu">=</span> bracket
        resourceInitialize
        (\resource <span class="ot">-&gt;</span> finalize resource)
        (\resource <span class="ot">-&gt;</span> eval resource)</code></pre></div>
<p>При таком подходе финализация вообще замаскирована от любых исключений. Даже если он реализован иначе, то всё же стоит думать что автор не дурак и написал смарт-конструктор с безопасным финализатором, раз уж решено пользоваться им. Потому что если это не так, то вместо него стоило бы написать свой. Таким образом исключения могут возникнуть только внутри «вычисления».</p>
<p>Хорошо. Как в таком случае обернуть в <code>catch</code> только половину функции, которая соответствует только нашему «вычислению»? Наверное никак. Но вместо этого мы можем попробовать инвалидировать финализатор.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="ot">{-# LANGUAGE Rank2Types #-}</span>

<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Control.Exception</span> ( allowInterrupt )
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.IORef</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.Catch</span>
<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.Managed</span></code></pre></div>
<p>Чтобы быть <code>MonadCatch</code>, надо сначала стать <code>MonadThrow</code>. Но тут всё очевидно.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">MonadThrow</span> <span class="dt">Managed</span> <span class="kw">where</span>
<span class="fu">&gt;</span>     throwM <span class="fu">=</span> liftIO <span class="fu">.</span> throwM</code></pre></div>
<p>Затем изобразим функцию <code>catch</code> для типов, которые скрывает <code>Managed</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> managedCatch ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> ((a <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> r) <span class="ot">-&gt;</span> <span class="dt">IO</span> r
<span class="fu">&gt;</span> managedCatch eval handler next <span class="fu">=</span> <span class="kw">do</span>
<span class="fu">&gt;</span>     ref <span class="ot">&lt;-</span> newIORef handler
<span class="fu">&gt;</span>     <span class="kw">let</span> handler&#39; e n <span class="fu">=</span> readIORef ref <span class="fu">&gt;&gt;=</span> \h <span class="ot">-&gt;</span> h e n
<span class="fu">&gt;</span>     catch (eval (\v <span class="ot">-&gt;</span> mask_ (writeIORef ref (\e _ <span class="ot">-&gt;</span> throwM e)) <span class="fu">&gt;&gt;</span> next v)) (\e <span class="ot">-&gt;</span> handler&#39; e next)</code></pre></div>
<p>Ну и сам инстанс будет выглядеть как-то так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">MonadCatch</span> <span class="dt">Managed</span> <span class="kw">where</span>
<span class="fu">&gt;</span>     catch eval handler <span class="fu">=</span> managed <span class="fu">$</span> managedCatch (with eval) (with <span class="fu">.</span> handler)</code></pre></div>
<p>Всё. Можно перехватывать и обрабатывать исключения. У этого подхода есть как минимум следующие недостатки:</p>
<ul>
<li>Нужна целая одна переменная. Кметту можно даже не пытаться показывать — проклянёт.</li>
<li>Всё вычисления от момента использования <code>catch</code> и до последнего связанного выражения на самом деле завёрнуто в <code>catch</code>, а если их несколько штук к ряду то на самом деле это матрёшка. И тут возникает нюанс: я точно не знаю как устроена обработка исключений в ghc, но все известные мне реализации <code>catch</code> подразумевают если и не копирование всего стека перед вхождением <code>catch</code>, то хотя бы его заморозку. Иначе не получится вернутся к состоянию стека до вызова <code>catch</code>. В общем случае это значит, что часть объектов на стеке будут удерживаться даже если бы в любом другом случае их собрал gc. Здесь же это удерживание будет продолжаться дольше чем надо вплоть до самого конца региона. Это проблема. Но с другой стороны это проблема не только данного решения, но и функций <code>withSomeThing</code> вообще так что хрен с ним.</li>
<li>Если асинхронное исключение прилетит после того после того как завершилось «вычисление», но до того как отработает маскировка, будет вызван оригинальный обработчик исключения, который сделает что-то. Беда-огорчение.</li>
</ul>
<p>Этот уровень можно считать условно пройденным. Дальше <code>MonadMask</code> и с ним всё хуже.</p>
<p>Попробуем понять, что должна делать и чего делать не должна функция <code>mask</code> для <code>Managed</code>. Видимо исходя из предположения в начале она должна маскировать «вычисление» и не маскировать «финализатор». Почему нужно не маскировать «финализатор»?</p>
<ul>
<li>Чтобы создать гомогенность поведения и не порождать неожиданных эффектов в конце выполняемого блока <code>catch</code> не ловит исключения в «финализаторе», а <code>mask</code> не маскирует «финализатор».</li>
<li>Для безопасности. Мы снова возвращаемся к тому вопросу, что «финализатор» написан человеком, который представляет себе как надо выделять и освобождать ресурс. Вероятнее всего он уже замаскирован, но если это не так, то для этого скорее всего были веские причины.</li>
</ul>
<p>Проблема в том, что <code>mask</code> маскирует функцию, а с точки зрения кода «вычисление» и «финализатор» это одна функция и замаскировать её мы можем только целиком. Хорошо, расчехляем <code>allowInterrupt</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> managedMask ::</span> ((forall b<span class="fu">.</span> <span class="dt">Managed</span> b <span class="ot">-&gt;</span> <span class="dt">Managed</span> b) <span class="ot">-&gt;</span> <span class="dt">Managed</span> a) <span class="ot">-&gt;</span> <span class="dt">Managed</span> a
<span class="fu">&gt;</span> managedMask eval <span class="fu">=</span>
<span class="fu">&gt;</span>     managed <span class="fu">$</span> \next <span class="ot">-&gt;</span>
<span class="fu">&gt;</span>         mask <span class="fu">$</span> \unmask <span class="ot">-&gt;</span>
<span class="fu">&gt;</span>             with (eval <span class="fu">$</span> managedRestore unmask) <span class="fu">$</span> \resource <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="fu">&gt;</span>                 v <span class="ot">&lt;-</span> unmask (next resource)
<span class="fu">&gt;</span>                 allowInterrupt
<span class="fu">&gt;</span>                 return v

<span class="fu">&gt;</span><span class="ot"> managedRestore ::</span> (forall a<span class="fu">.</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">Managed</span> b <span class="ot">-&gt;</span> <span class="dt">Managed</span> b
<span class="fu">&gt;</span> managedRestore oldRestore eval <span class="fu">=</span> managed <span class="fu">$</span> \next <span class="ot">-&gt;</span> oldRestore <span class="fu">$</span> with eval next</code></pre></div>
<p>Всё? Нет. Нужен ещё <code>uninterruptibleMask</code>. Он понятное дело выглядит абсолютно аналогично предыдущему коду, но есть одно но: <code>allowInterrupt</code> не производит никакого эффекта будучи вызванным из <code>uninterruptibleMask</code>. Другого способа размаскировать «финализатор» я не знаю и если по какой-то причине он зависнет то это уже навсегда. Кроме того это создаёт ощутимую разницу с <code>mask</code> в поведении. Что делать?</p>
<ul>
<li>Гомогенезировать поведение. Разрешить <code>mask</code> маскировать «финализатор», a <code>catch</code> ловить исключения в финализаторе. Это не сложно, но я уверен что это не совсем то поведение, которое хотелось бы видеть.</li>
<li>Пойти на сомнительную сделку с собственной совестью и решить что <code>uninterruptibleMask</code> всё равно никто толком не использует примерно никогда, а если и использует то на коротких, гарантированно завершающихся функциях, у которых почти наверняка нет «финализатора».</li>
<li>Страдать и признать поражение и страдать.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">MonadMask</span> <span class="dt">Managed</span> <span class="kw">where</span>
<span class="fu">&gt;</span>     mask                <span class="fu">=</span> managedMask
<span class="fu">&gt;</span>     uninterruptibleMask <span class="fu">=</span>
<span class="fu">&gt;</span>         \eval <span class="ot">-&gt;</span> managed <span class="fu">$</span> \next <span class="ot">-&gt;</span>
<span class="fu">&gt;</span>             uninterruptibleMask <span class="fu">$</span> \unmask <span class="ot">-&gt;</span>
<span class="fu">&gt;</span>                 with (eval <span class="fu">$</span> managedRestore unmask) <span class="fu">$</span> (unmask <span class="fu">.</span> next)</code></pre></div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Также важным недостатком данной схемы является то что можно вернуть ресурс из блока кода после того как отработали все финализаторы и он в лучшем случае больше недоступен. Но во-первых насколько я понимаю эта проблема характерна и для resourcet-подобных решений, во-вторых это совсем другая долгая и печальная история.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>О MskHUG в декабре 2015го года…</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-12-11-meetup.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-12-11-meetup.html</id>
    <published>2015-12-11T00:00:00Z</published>
    <updated>2015-12-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Сходил на слёт хаскелистов в Яндексе, послушал доклады. Коротко:</p>
<ul>
<li><p>Лучший доклад был пожалуй про Servant. Человек настолько задороно выступил, что мне захотелось оный Servant потыкать, хотя у меня и нет задач для которых мог бы понадобится веб-сервер. Чуваку, который сравнивал сложность комбинирования роутов веб-сервера и сложность комбинирования парсеров в parsec посылаю луч ненависти: во втором случае сложность вылезает из-за типично нетревиальных грамматик и того что парсек говно и не умеет в бэктрекинг (но это совсем другая история).</p></li>
<li><p>Наиболее полезным для меня оказался доклад про зависимые типы, который оказался не про зависимые типы, а про костыли в GHC, которые позволяют типизировать типы типами. Собственно я наконец примерно понял как работает этот механизм. А вот квантор <code>pi</code> мне напомнил С++14 с его <code>decltype(auto)</code>.</p></li>
<li><p>Зефиров опять рассказывал что-то очень интересное и я опять мало что смог вынести из доклада: во-первых опоздал к началу, во-вторых сам доклад проводился в экстремальных условиях и в-третьих Зефиров довольно хреновый докладчик.</p></li>
<li><p>Крайне полезным был доклад <span class="citation">@qnikst</span>’а. Жаль что он не успел его дочитать. Всё бы ничего, но мне как-то стабильно не нужно вызывать внешние функции из haskell руками. Обычно дело ограничивается сериализацией/десериализацией сишных структур прилетевших из ядерных интерфейсов. Хотя идея хакнуть рантайм через unsafe ffi-вызовы, которые блокируют тред и gc мне показалась очень интересной, хотя и вредной.</p></li>
<li><p>Посмотрел на живого <del>Ленина</del><span class="citation">@qnikst</span>’а. Он классный <del>,от него сияние исходит</del>.</p></li>
<li><p>Попытался объяснить живому <span class="citation">@segfault</span>’у радость комбинатора неподвижной точки.</p></li>
<li><p>Попытался объяснить живому <span class="citation">@segfault</span>’у радость GREEN’а, полнопрограмной компиляции и отказа от стека в пользу распихивания аргументов функций по фиксированным непересекающимся регистрам.</p></li>
</ul>
<p>Больше не сделал ничего ползного. В следующий раз нужно будет запастись:</p>
<ul>
<li><p>Бейджем с ником на жуйке.</p></li>
<li><p>Карточками с вопросами, чтобы передавать их по кругу по столу во время неформальной части.</p></li>
<li><p>Докладом про Remote Monad, если к этому времени мой <code>Action</code> будет честным частным случаем.</p></li>
</ul>]]></summary>
</entry>
<entry>
    <title>О скоупах</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2015-08-02-scope.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2015-08-02-scope.html</id>
    <published>2015-08-02T00:00:00Z</published>
    <updated>2015-08-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>А вот ещё одна хитрая задачка. Положим у нас есть несколько устройств, которые мы можем как-то дёргать через <code>DevHnd a</code> (где <code>a</code> — тип-параметр характеризующий устройство). Проблема в том, что если два треда будут рулить устройством одновременно, то результат будет трудно предсказать. Хорошо, вводим концепцию владения устройством: управлять устройством<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> можно только завладев им, если кто-то другой завладел устройством до тебя, то ты ждёшь пока устройство освободится. Просто, но есть пара нюансов:</p>
<ul>
<li>мы говорим «блокировка» и подразумеваем «дедлок», поскольку в реальной жизни тред должен контролировать состояние более одного устройства одновременно;</li>
<li>из типа <code>DevHnd a</code> никак не следует захвачен ли он текущим тредом, а значит проверка этого факта будет осуществляться в рантайме каждый раз когда мы будем модифицировать устройство и более того время от времени мы будем сталкиваться с ошибками времени исполнения.</li>
</ul>
<p>В общем случае, когда устройства захватываются и высвобождаются в произвольный момент времени ни первую, ни вторую проблему мы вероятнее всего не решим. Но если рассмотреть ситуацию когда все устройства захватываются и освобождаются одновременно ситуация перестаёт быть такой удручающей и внезапно укладывается в традиционный для haskell’я паттерн:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> c <span class="ot">-&gt;</span> <span class="dt">IO</span> c
    withSomething dev1 dev2 action <span class="fu">=</span> <span class="kw">do</span>
        alloc dev1 dev2
        v <span class="ot">&lt;-</span> action
        dealloc dev1 dev2
        return v</code></pre></div>
<p>Способов заблокировать несколько сущностей одновременно избежав дедлоков более одного, выберите по вкусу. Но <code>action</code> всё равно может содержать действия с устройствами, которые мы не захватили. Чтобы этого избежать можно сделать следующее:</p>
<ul>
<li>введём изоморфный <code>DevHnd a</code> тип <code>StaticHnd s a</code> с фантомным параметром <code>s</code> и приватную функцию <code>toStatic</code> делающую из первого второе;</li>
<li>введём изоморфную <code>IO a</code> монаду <code>Scope a</code>, а также функции для управления устройствами внутри этой монады через <code>StaticHnd s a</code>;</li>
<li>перепишем предыдущий код так:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c
    withSomething dev1 dev2 action <span class="fu">=</span> <span class="kw">do</span>
        alloc dev1 dev2
        v <span class="ot">&lt;-</span> action (toStatic dev1) (toStatic dev2)
        dealloc dev1 dev2
        return v</code></pre></div>
<p>Всё. Теперь следим за руками:</p>
<ul>
<li>изменять в нашем скоупе устройства через <code>DevHnd a</code> мы не можем, поскольку соответствующий мутатор не определён для <code>Scope a</code>;</li>
<li>создать <code>StaticHnd s a</code> мы можем только при помощи <code>withSomething</code>, поскольку <code>toStatic</code> не экспортирован наружу;</li>
<li>вернуть <code>StaticHnd s a</code> из <code>action</code> мы тоже не можем, поскольку функция не может вернуть значение любого типа, а фантомный параметр <code>s</code> передаваемых в неё аргументов объявлен как <code>forall</code>.</li>
</ul>
<p>Из всего этого следует что любая попытка использовать внутри нашего скоупа не захваченное устройство или устройство захваченное в другой скоуп (кроме родительского :^)) завершится <strong>ошибкой компиляции</strong>. Хорошо? Очень хорошо. Но на этом хорошее заканчивается и начинается Real World.</p>
<p>Приведённый код определён для двух устройств захватываемых в скоуп. Очевидным образом это довольно частный случай и этого мало. Также очевидно что функция <code>withSomething</code> содержит детали приватной реализации и должна быть чёрным ящиком. Есть несколько вариантов решения:</p>
<ul>
<li><p>Наиболее распространённым решением таких проблем в haskell’е это… унылая копипаста в результате которой получатся функции вида:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withSomething ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c

<span class="ot">withSomething2 ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> <span class="dt">Scope</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c

<span class="ot">withSomething3 ::</span> <span class="dt">DevHnd</span> a <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> b <span class="ot">-&gt;</span> <span class="dt">DevHnd</span> c <span class="ot">-&gt;</span>
    (forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s a <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s b <span class="ot">-&gt;</span> forall s<span class="fu">.</span> <span class="dt">StaticHnd</span> s c <span class="ot">-&gt;</span> <span class="dt">Scope</span> d) <span class="ot">-&gt;</span> <span class="dt">IO</span> d</code></pre></div>
<p>И так до тех пор пока не надоест.</p></li>
<li><p>Также можно попробовать изобразить композицию.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">action <span class="fu">=</span>
    withSomething hnd1 <span class="fu">$</span> \sHnd1 <span class="ot">-&gt;</span>
        withSomething hnd2 <span class="fu">$</span> \sHnd2 <span class="ot">-&gt;</span>
            withSomething hnd3 <span class="fu">$</span> \sHnd3 <span class="ot">-&gt;</span> <span class="kw">do</span>
                doSomething sHnd1
                doSomething sHnd2
                doSomething sHnd3</code></pre></div>
<p>Но так мы теряем возможность захватывать устройства одной транзакцией (у каждого <code>withSomething</code> своя транзакция). В принципе это можно пофиксить введя ещё одну стадию заправки ракеты:</p>
<ul>
<li>вводим ещё одну монаду<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> (например Accure a) внутри которой можно делать только withSomething и run;</li>
<li>withSomething просто добавляет захват очередного устройства в готовящуюся транзакцию;</li>
<li>run запускает транзакцию и затем выполняет наш Scope.</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    action <span class="fu">=</span> accure <span class="fu">$</span>
        withSomething hnd1 <span class="fu">$</span> \sHnd1 <span class="ot">-&gt;</span>
            withSomething hnd2 <span class="fu">$</span> \sHnd2 <span class="ot">-&gt;</span>
                withSomething hnd3 <span class="fu">$</span> \sHnd3 <span class="ot">-&gt;</span> run <span class="fu">$</span> <span class="kw">do</span>
                    doSomething sHnd1
                    doSomething sHnd2
                    doSomething sHnd3</code></pre></div>
<ul>
<li><p>Наконец есть магия в стиле <code>Applicative</code> позволяющая писать что-то в духе:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(\v1 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1
(\v1 v2 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1 <span class="fu">&lt;*&gt;</span> doSome2
(\v1 v2 v3 <span class="ot">-&gt;</span> … ) <span class="fu">&lt;$&gt;</span> doSome1 <span class="fu">&lt;*&gt;</span> doSome2 <span class="fu">&lt;*&gt;</span> doSome3</code></pre></div>
<p>Я даже видел как что-то подобное использовали в parsec’е, но от попыток натянуть это на свои типы у меня стабильно плавится мозг.</p></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>В данном случае это не так принципиально, но под управлением устройством разумеется подразумевается изменение его состояния.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Если у вас монада головного мозга конечно. Достаточно моноида, же.<a href="#fnref2">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Почему хаскель не подходит для скриптования?</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-06-13-why-haskell-bad-for-scripting.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-06-13-why-haskell-bad-for-scripting.html</id>
    <published>2014-06-13T00:00:00Z</published>
    <updated>2014-06-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Прежде чем обсуждать недостатки такого безусловно примечательного инструмента следует определиться с таким самоочевидным понятием как скриптование. Речь пойдёт в первую очередь о так называемых скриптах пользователя: небольших программах обеспечивающих интерфейс взаимодействия пользователя и более сложной системы. Например скрипты emacs’а, vim’а или даже acpid’а. В определённой степени можно говорить и командной оболочке операционной системы в принципе с некоторыми оговорками. Следует различать пользовательские скрипты и приложения для одного запуска: последние могут сколь угодно сложны, громоздки, запутаны, не очевидны и нечитабельны, поскольку читать их никто не будет и пишутся они обычно на одном дыхание, а со своими скриптами вам скорее всего ещё долгое время жить. Итак пользовательский скрипт это программа:</p>
<ul>
<li>предоставляющая интерфейс к более сложной системе чем система самого скрипта (в противном случае было бы проще поправить код системы)<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>;</li>
<li>небольшая (в противном случае кто кого скриптует и кто куда встроен<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>);</li>
<li>понятная (поскольку никто даже комментариев не пишет, не говоря уж про документацию);</li>
<li>как правило не критичная по производительности.</li>
</ul>
<p>Для таких задач традиционно используются shell, lua, js, scheme и прочие языки поразительно схожие с этими синтаксисом и семантикой (хотя некоторые умудряются для этого сравнительно успешно использовать целый python). Что объединяет эти языки? Слабая (у всех кроме scheme) динамическая типизация и позднее связывание. Оно и понятно, считается что если убрать из программы аннотацию типов то она станет выглядеть проще. Однако на сдачу мы получаем невозможность проверить хотя бы наличие вызываемых функций и существование используемых переменных не говоря уж о разумности применения одного к другому. Поскольку покрывать тестами подобного рода код будут немного позже того как к нему напишут документацию, то ситуация выглядит так себе.</p>
<p>При этом следует понимать, что статическая типизация и ранее связывание вообще говоря совсем не требуют аннотации типов. Компилятор зачастую может понять какой тип имеет то или иное выражение просто из контекста используемых функций. Компилятор может осуществлять вывод типов даже в таком языке как C++, где система типов вообще один из кругов Ада. Для более простого языка это осуществить ещё проще. Всё что ему нужно это твёрдая уверенность, что в середине выполнения программы не появятся новые функции, а семантика существующих типов не изменится. Довольно забавно, но для очерченных нами задач это практически всегда верно поскольку для решения простых задач такие динамические возможности едва ли понадобятся, а сложные мы вроде бы решать и не собирались<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p>Теперь посмотрим в свете наших задач на Haskell. Итак Haskell это ленивый, функциональный язык программирования с полиморфизмом на классах типов:</p>
<ul>
<li>вывод типов вместо динамической типизации: прекрасно работает;</li>
<li>функции высшего порядка вместо метапрограммирования: с учётом возможности определять операторы и тем что у основных конкурентов нет разделения на время компиляции и время исполнения, ок;</li>
<li>полиморфизм всего и вся вместо динамической диспетчеризации: вполне хватает;</li>
</ul>
<p>Плюс сопоставление с образцом, которое у конкурентов как правило отсутствует (ну кроме scheme и прочих лиспов). Что не так? А не так примерно следующее:</p>
<ul>
<li><p>Плохая стандартная библиотека. Многие вещи сделаны плохо поскольку пришли к нам из тех времён когда функциональные языки не умели готовить. Многие вещи сделаны плохо поскольку сделано с учётом особенностей реализации ghc. Так например несмотря на полиморфизм, большая часть функций Prelude мономорфна по используемому контейнеру. Или по используемому числовому типу. В той же стандартной библиотеке есть полиморфные функции, но они запрятаны в другие модули и часто создают конфликт имён, разрешение которого портит всю радость. Ну и за Monad который не Functor отдельное спасибо.</p></li>
<li><p>Сложная стандартная библиотека. В Prelude есть целых два типа для для обозначения целого знакового числа: Int (для числа размером в машинное слово) и Integer (для целого числа бесконечной точности). В Data.Int можно найти целые числа другого размера, а в Data.Word беззнаковые целые числа. Такое разнообразие типов безусловно не доведёт до добра скриптописателя. Он может <del>испугаться</del>начать решать проблемы производительности и не допишет свой скрипт никогда, поскольку будет писать стандартные функции для работы с Word8, отсутствующие в стандартной библиотеке. Для сравнение Lua использует только один тип — Number, который представляет собой закоробкованное число с плавающей запятой двойной точности (то есть Double).</p></li>
<li><p>Стандарт языка. Haskell2010 довольно простой язык у которого есть всё чтобы писать на нём программы. Однако программы эти будут содержать чёртову уйму бойлерплейта, интересных структур данных и коллизий пространств имён. Можно воспользоваться расширениями GHC. Код безусловно станет лаконичнее и яснее, но возникнут другие проблемы: выбор языковых средств (самый банальный пример это функциональные зависимости vs семейства типов), неоднозначности приводящие к трудности проверки типов, усложнение системы типов настолько что язык становится понятным вообще только компилятору. А ещё расширений так много что весь GHC-haskell не знает никто. Вместе с этим, стандартная библиотек старается по возможности избегать языковых расширений, что делает её именно такой как было описано в начале.</p></li>
<li><p>Реализация. Мне на сегодняшний день доводилось иметь дело с тремя реализациями haskell.</p>
<ul>
<li><p>GHC. Мы говорим haskell подразумеваем GHC. Мы говорим о стандартной библиотеке haskell подразумеваем base, а вовсе не haskell2010. Если вы хотите использовать существующие библиотеки то вам придётся использовать GHC. Впрочем это очень хороший компилятор с очень мощной и гибко настраиваемой рантайм-системой: в то время как кто-то всё ещё считает ссылки и никак не выпилит GIL, рантайм-система GHC вертит тысячами тредов и дефрагментирует кучу. Однако у этого всего есть оборотная сторона. GHC громоздок, как в сборке так и в виде библиотеки, а его рантайм избыточен и на небольших приложениях выглядит как лазерная атака из космоса для того чтобы поджарить тосты. Несмотря на все ухищрения и тюнинг рантайма ваше приложение вряд ли будет использовать меньше мегабайта под кучу. Не исключено, что больше тоже вряд ли, но тем не менее.</p></li>
<li><p>Jhc/Ajhc. Компилятор haskell в C. Если GHC придерживается традиционной модели компиляции, где есть раздельная компиляция различных единиц трансляции, а затем линковка, то Jhc проводит анализ, трансформации и компиляцию всего кода проекта. Полученный код на C отчаянно пытается управлять памятью при помощи выведенных регионов, но не справляется и всё в итоге опять скатывается в сканирующую сборку мусора. Эта реализация намного проще и компактнее, но по своей природе больше стремиться быть хаскелем для микроконтроллеров. Язык который она поддерживает — Haskell98 и несколько GHC-шных расширений того времени. Для нашей задачи она бесполезна.</p></li>
<li><p>Haste. Компилятор haskell в JS. Несмотря на жутковатый мапинг данных хаскеля в данные JS и время от времени возникающие проблемы с продолжениями, эта реализация ближе всего к нашим задачам. Haste использует фронтенд ghc и работает уже непосредственно с stg-кодом. Это решает проблему расширений, поскольку почти все они реализованы на уровне фронтенда. И всё же это 40 мегабайт компилятора и 13 — nodejs. Многовато. Кроме того v8 жрёт памяти как не в себя и встраивается только инженерами гугла.</p></li>
</ul></li>
<li><p>Слишком много приведений типов. Вот код на хаскеле:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  avrg xs <span class="fu">=</span> sum xs <span class="fu">/</span> length xs</code></pre></div>
<p>Среднее по списку значение это сумма всех значений в списке разделённая на длину списка. Всё хорошо? Нет. Оператор (/) не определён для целочисленного типа. Длинна списка это значение типа Int. Но даже если она будет Integer или сферический целочисленный тип в вакууме (Integral) ничего не изменится: делитель, делимое и результат должны быть одного типа, а в данном случае нас интересует именно нецелочисленный результат<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. Нужно писать как-то так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  avrg xs <span class="fu">=</span> sum xs <span class="fu">/</span> fromIntegral (length xs)</code></pre></div>
<p>В lua нет такой проблемы поскольку как уже писалось выше там всего один тип для записи чисел вообще. Однако в C (от которого в известной степени хаскель унаследовал примитивные типы) такой проблемы тоже нет: компилятор просто неявно приводит целое число к какой-нибудь плавучке.</p></li>
</ul>
<p>Пущей объективности ради следует заметить, что языки из круга конкурентов совсем не обязательно лишены подобных недостатков. И тем не менее будем считать что всё дело именно в них. Если всё перечисленное плохо и не нужно, то что нужно?</p>
<ul>
<li><p>Компилятор некого семантического надмножества Haskell2010. Стандарт довольно ядра языка довольно лаконичен. Возможно можно было бы исключить из него newtype поскольку он опять же заставляет задумываться, а в нашем случае это плохо. Из расширений стоит оставить:</p>
<ul>
<li><p>Многопараметрические классы типов и функциональные зависимости. Концептуальным решением было бы даже ограничиться классами где все параметры кроме одного зависимы<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p></li>
<li><p>Перегрузка оставшихся немногочисленных литералов. В стандарте перегружены числовые литералы и do-нотация. Соответственно остаётся перегрузить строковые (есть в ghc) и списки (есть в ghc).</p></li>
<li><p>GADT’ы. Упрощают описание древовидных структур и гетерогенных коллекций.</p></li>
<li><p>Data/Generic и прочее обобщённое программирование. В плане унылости мало что может потягаться с case’ом по двенадцати конструкторам, одиннадцать веток которого не делают ничего.</p></li>
<li><p>Управляемое неявное приведение типов.</p></li>
</ul></li>
<li><p>Компиляция неразделяемого кода. Шаблонный полиморфизм как в C++ и jhc. Тотальный инлайнинг и трансформация всего кода программы (интересно, насколько это реально в условиях just it time компиляции).</p></li>
<li><p>Кодогенератор в некую простую существующую переносимую виртуальную машину или даже язык. Предпочтительнее система со сканирующей сборкой мусора (что-то кондовое вроде mark &amp; sweep) и без jit-компилятора. Писать свою динамическую среду исполнения не стоит. Их уже итак больше чем нужно.</p></li>
<li><p>Простая стандартная библиотека.</p>
<ul>
<li><p>Было бы забавно обозвать монаду аппликативным функтором, но не понятно насколько это будет корректно.</p></li>
<li><p>Foldable и Traversable сделать классами от двух переменных где тип содержимого зависит от типа контейнера.</p></li>
<li><p>Не хранить строки в виде списка чаров. Это вызывает слишком много волнения и других строк. По большому счёту строка это массив кодпоинтов, но непонятно как тогда осуществлять паттерн-матчинг.</p></li>
<li><p>Стандартизованный механизм и формат исключений (вот уже GADT и в стандартной библиотеке).</p></li>
<li><p>Стандартные монадные трансформеры? Почему бы и нет. Плюс монада для логического вывода с бэктрекингом.</p></li>
<li><p>Регулярные выражения и комбинаторы парсеров. Последнее вообще киллер-фича функциональшины и ML-подобных.</p></li>
<li><p>Стандартные контейнеры типа Map, Set и так далее.</p></li>
<li><p>Парсеры для работы c json, xml, yaml.</p></li>
</ul></li>
</ul>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Ну или у вас просто нет возможности поправить код системы. Но тогда горе побеждённым! Какой смысл обсуждать достоинства и недостатки brainfuck, если это единственный доступный вам способ изменить поведение вашей системы?<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Угу. Например в код emacs на elisp встроено небольшое ядро на C.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Существует спорное утверждение, что динамика очень нужна для создание EDSL’ей которые действительно позволяют повысить простоту кода и довольно эффективно съесть сложность и громоздкость кода.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Иначе у нас бы использовалось целочисленное деление.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Да-да. Это семейства типов. Но они выглядят более громоздкими. Функциональные зависимости более лаконичны что-ли.<a href="#fnref5">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>e</title>
    <link href="https://ndtimofeev.github.io/ru/posts/2014-05-24-e.html" />
    <id>https://ndtimofeev.github.io/ru/posts/2014-05-24-e.html</id>
    <published>2014-05-24T00:00:00Z</published>
    <updated>2014-05-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Четыре года назад, я радовался работе с бесконечными списками и вычислял e суммируя ряд Тейлора так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> map (\x <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">/</span> fac x) [<span class="dv">0</span><span class="fu">..</span>]
    <span class="kw">where</span>
        fac n <span class="fu">=</span> foldl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>n]
        sum (x<span class="fu">:</span>xs) <span class="fu">=</span> sumtr (x<span class="fu">:</span>xs) <span class="dv">0</span>
        sumtr (x<span class="fu">:</span>xs) acc
            <span class="fu">|</span> (acc <span class="fu">==</span> acc <span class="fu">+</span> x) <span class="fu">=</span> acc
            <span class="fu">|</span> otherwise <span class="fu">=</span> sumtr xs (x <span class="fu">+</span> acc)</code></pre></div>
<p>Случайно найдя предыдущий сниппет и смахнув слезу умиления, я переписал суммирование уже со знанием стандартной библиотеки.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> takeWhile (<span class="fu">/=</span><span class="dv">0</span>) <span class="fu">$</span> map (\v <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">/</span> product [<span class="dv">1</span><span class="fu">..</span>v]) [<span class="dv">0</span><span class="fu">..</span>]</code></pre></div>
<p>Проблема в том, что этот вариант аллоцировал в 10 раз больше памяти чем первый. Стало как-то неудобно и я заменил вычисление факториала для каждого нового члена ряда Тейлора на вычисление непрерывного списка факториалов, где каждый следующий элемент умножение номера члена ряда на значение предыдущего элемента.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> sum <span class="fu">$</span> takeWhile (<span class="fu">/=</span><span class="dv">0</span>) <span class="fu">$</span> map (<span class="dv">1</span><span class="fu">/</span>) <span class="fu">$</span> scanl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>]</code></pre></div>
<p>Количество аллоцированной памяти вышло на уровень первого варианта. Однако в первом варианте у нас используется наивный факториал и он всё равно работает замечательно. Разница состоит в том, что первый вариант суммирует ряд до тех пор пока сумма изменяется, а третий — до тех пор пока n-ый член ряда не станет нулём. Любому кто знаком с числами с плавающей запятой понятно что первое условие выполнится быстрее второго. Попробуем использовать именно первое условие. Для этого из бесконечного списка факториалов получим бесконечный список сумм, выделим пары текущая сумма/следующая сумма и будем разматывать список до тех пор пока суммы не равны. Последняя сумма и есть наша.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">e <span class="fu">=</span> fst <span class="fu">$</span> last <span class="fu">$</span> takeWhile (uncurry (<span class="fu">/=</span>)) <span class="fu">$</span> (\v <span class="ot">-&gt;</span> zip v (tail v)) <span class="fu">$</span> scanl1 (\v0 v1 <span class="ot">-&gt;</span> v0 <span class="fu">+</span> <span class="dv">1</span> <span class="fu">/</span> v1) <span class="fu">$</span> scanl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>]</code></pre></div>
<p>Мы наконец заметно превзошли по выделенной памяти первый вариант. Но не в 10 раз, а в полтора и ценой дополнительного времени на сборку мусора. Это скажем так себе результат.</p>
<p>P.S: Продолжение следует.</p>]]></summary>
</entry>

</feed>
