<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>All you need is love and little bit of LSD - О том как избежать успеха и как не избежать успеха…</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
        <link rel="alternate" type="application/atom+xml" title="Atom" href="../../atom.xml">
    </head>
    <body>
        <div id="container">
            <div id="header">
                <div id="logo">
                    <a href="../../">All you need is love and a little bit of LSD</a>
                </div>
                <div id="navigation">
                    <a href="../../ru/about.html">About</a>
                    <a href="../../archive.html">Archive</a>
                </div>
            </div>

            <div id="content">
                <h1>О том как избежать успеха и как не избежать успеха…</h1>
                <div class="info">
    
        Posted on May 20, 2016 with tags: <a href="../../ru/tags/Haskell.html">Haskell</a>.
    
</div>


<p>При всём богатстве возможностей в Haskell регулярно возникают проблемы с вещами, которые кажутся совершенно элементарными. Например получить стек вызовов в случае ошибки. Причём не то что бы его нельзя получить совсем, наоборот есть как минимум два ортогональных способа, но всё это сопряжено с таким количеством сложностей и условий, что проще воткнуть в нужные места printf’ы или густо обмазываться препроцессором. Особенно грустно дело с этим обстояло в ghci.</p>
<p>И вот для пользователей ghci наступает <a href="http://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html">революция</a>. Казалось бы страдания остались в прошлом, а <code>error</code> и <code>undefined</code> обрели практическое применение. Однако первая же попытка использовать это в массиве написанного кода обернулась неудачей: <code>error</code> и <code>undefined</code> выдавали стек вызовов, а броски исключения — нет. Сначала я подозревал себя в том, что куда-то не включил профилировочную информацию или как-то не так использую ImplicitParams, но потом я просто полез в код.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Err.hs:77</span>
<span class="ot">    undefined ::</span> forall (<span class="ot">r ::</span> <span class="dt">RuntimeRep</span>)<span class="fu">.</span> forall (<span class="ot">a ::</span> <span class="dt">TYPE</span> r)<span class="fu">.</span>
                 <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> a
    undefined <span class="fu">=</span>  error <span class="st">&quot;Prelude.undefined&quot;</span></code></pre></div>
<p>Тут всё понятно: <code>undefined</code> это такой частный случай <code>error</code> для тех кому не хватило фантазии написать осмысленное сообщение. Улыбаемся “Prelude.undefined” и двигаемся дальше.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Err.hs:36</span>
<span class="ot">    error ::</span> forall (<span class="ot">r ::</span> <span class="dt">RuntimeRep</span>)<span class="fu">.</span> forall (<span class="ot">a ::</span> <span class="dt">TYPE</span> r)<span class="fu">.</span>
             <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> a
    error s <span class="fu">=</span> raise<span class="fu">#</span> (errorCallWithCallStackException s <span class="fu">?</span>callStack)</code></pre></div>
<p>Тут в принципе ожидалось увидеть что-то вроде <code>throw . ErrorCall</code>, но не оно. С другой стороны <code>raise#</code> это такой primop, который реализует throw, так что <code>errorCallWithCallStackException</code> должен быть таким замысловатым способом сконструировать исключение. За подтверждением лезем в <code>GHC.Exception</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Exception.hs:171</span>
    <span class="kw">data</span> <span class="dt">ErrorCall</span> <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> <span class="dt">String</span> <span class="dt">String</span>
        <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)

    pattern <span class="dt">ErrorCall</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ErrorCall</span>
    pattern <span class="dt">ErrorCall</span> err <span class="ot">&lt;-</span> <span class="dt">ErrorCallWithLocation</span> err _ <span class="kw">where</span>
      <span class="dt">ErrorCall</span> err <span class="fu">=</span> <span class="dt">ErrorCallWithLocation</span> err <span class="st">&quot;&quot;</span>

    <span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">ErrorCall</span>

    <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">ErrorCall</span> <span class="kw">where</span>
      showsPrec _ (<span class="dt">ErrorCallWithLocation</span> err <span class="st">&quot;&quot;</span>) <span class="fu">=</span> showString err
      showsPrec _ (<span class="dt">ErrorCallWithLocation</span> err loc) <span class="fu">=</span> showString (err <span class="fu">++</span> <span class="ch">'\n'</span> <span class="fu">:</span> loc)

<span class="ot">    errorCallException ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeException</span>
    errorCallException s <span class="fu">=</span> toException (<span class="dt">ErrorCall</span> s)</code></pre></div>
<p>Первое что нас удивляет: конструктор <code>ErrorCall</code> теперь называется как-то по другому и таскает не одну строчку, а два. Впрочем если посмотреть <a href="http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html">тут</a> то фокус с конструктором и синонимом становится понятен.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Exception.hs:187</span>
<span class="ot">    errorCallWithCallStackException ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">CallStack</span> <span class="ot">-&gt;</span> <span class="dt">SomeException</span>
    errorCallWithCallStackException s stk <span class="fu">=</span> unsafeDupablePerformIO <span class="fu">$</span> <span class="kw">do</span>
      ccsStack <span class="ot">&lt;-</span> currentCallStack
      <span class="kw">let</span>
        implicitParamCallStack <span class="fu">=</span> prettyCallStackLines stk
        ccsCallStack <span class="fu">=</span> showCCSStack ccsStack
        stack <span class="fu">=</span> intercalate <span class="st">&quot;\n&quot;</span> <span class="fu">$</span> implicitParamCallStack <span class="fu">++</span> ccsCallStack
      return <span class="fu">$</span> toException (<span class="dt">ErrorCallWithLocation</span> s stack)</code></pre></div>
<p>Теперь собственно виновник торжества. Получаем явный стек в качестве переменной, достаём стек профилировщика хакнув IO, красиво рисуем, склеиваем, запихиваем в расширенный <code>ErrorCall</code> вместе с сообщением, заворачиваем в <code>SomeException</code>. Если посмотреть на инстанс <code>Show</code> для <code>ErrorCall</code>, то можно увидеть код, который рисует стек если соответствующее поле заполнено. Снаружи никаких изменений в <code>ErrorCall</code> не видно. Отличный пример того как можно при помощи паттерн-синонимов в GHC8 можно изобразить инкапсуляцию. Теперь смотрим на <code>throw</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- ./libraries/base/GHC/Exception.hs:166</span>
<span class="ot">    throw ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> a
    throw e <span class="fu">=</span> raise<span class="fu">#</span> (toException e)</code></pre></div>
<p>Ну конечно. Тут просто неоткуда взяться стек-трейсу. Да как бы он хранился в исключение произвольного типа? Разве что как-то так:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">data</span> <span class="dt">SomeException</span> <span class="kw">where</span>
        <span class="dt">SomeExceptionWithLocation</span><span class="ot"> ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">SomeException</span>

    pattern <span class="dt">SomeException</span><span class="ot"> ::</span> () <span class="ot">=&gt;</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">SomeException</span>
    pattern <span class="dt">SomeException</span> err <span class="ot">&lt;-</span> <span class="dt">SomeExceptionWithLocation</span> _ err <span class="kw">where</span>
      <span class="dt">SomeException</span> err <span class="fu">=</span> <span class="dt">SomeExceptionWithLocation</span> <span class="st">&quot;&quot;</span> err</code></pre></div>

            </div>
            <div id="footer-push"></div>
        </div>
        <div id="footer-menu">
            
                
                        <a href="../../ru/posts/2016-05-20-GHC8-callstack.xml">Subscribe to post updates</a>
                
                        <a href="../../ru/posts/2016-05-20-GHC8-callstack.disqus.html">To disqus</a>
                
            
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
